---
title: "[해싱] 카운팅"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-12 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

카운팅은 해시 맵에서 자주 사용되는 패턴이다. "카운팅"은 어떤 것의 빈도수를 추적하는 것을 의미한다. 이때 해시 맵은 키와 값을 정수로 연결한다. 계산이 필요할 때마다 해시 맵을 활용하여 해결할 수 있다.

슬라이딩 윈도우를 사용할 때 일부 문제에서는 윈도우 내 특정 요소의 수에 제한이 있다는 것을 주목하자. 예를 들면, `0`이 최대 `k`개인 가장 긴 부분 문자열과 같은 문제가 있다. 이 문제에서는 하나의 요소만을 중점으로 다루었기 때문에(`0`만을 고려했기 때문에) 정수 변수 `curr`만을 사용했다. 하지만 해시 맵은 제약이 여러 요소에 걸쳐 있을 때의 문제를 해결하는 데 도움을 준다. 이제 해시 맵을 사용하는 슬라이딩 윈도우의 예시를 살펴보자.

---

> **예제 1**: 문자열 `s`와 정수 `k`가 주어질 때, `k`개의 고유 문자를 **최대로** 포함하는 가장 긴 부분 문자열의 길이를 구하라.
>
> 예시로, `s = "eceba"`, `k = 2`라면, 답은 `3`이다. `2`개의 고유 문자를 최대로 포함하는 가장 긴 부분 문자열은 `"ece"`이다.
{: .prompt-general }

이 문제는 부분 문자열에 대한 제약 조건(최대 `k`개의 고유 문자)을 가진다. 이런 특성으로 인해 슬라이딩 윈도우 방식을 고려할 수 있다. 슬라이딩 윈도우는 제약 조건을 만족시키지 못하게 될 때까지 오른쪽으로 확장되며, 만약 제약 조건을 위반하게 되면, 그 조건을 다시 만족시킬 때까지 왼쪽을 줄여나간다. 제약 조건의 확인을 위해 모든 윈도우를 매번 검사하는 방식은 $$O(n)$$의 시간이 걸린다. 하지만 해시 맵을 사용하면 $$O(1)$$의 시간에 제약 조건을 확인할 수 있다.

윈도우에 있는 문자의 빈도를 계산하기 위해 해시 맵 `count`를 사용해보자. 문자를 그 빈도에 매핑하는 것이다. `count`의 크기(키의 수)는 현재 윈도우에 있는 고유 문자의 수를 의미한다. 왼쪽에서 문자를 제거할 때, 해당 문자의 빈도를 감소시키고, 빈도가 `0`이 되면, 그 문자는 윈도우에 더 이상 포함되지 않으므로 해당 키를 삭제한다.

> 파이썬에서 [컬렉션 모듈](https://docs.python.org/3/library/collections.html)은 다양한 유용한 데이터 구조를 제공한다. 하지만 여기서는 파이썬의 기본 딕셔너리를 사용할 것이다. 이 기본 [딕셔너리](https://docs.python.org/3/library/collections.html#collections.defaultdict)는 기능적으로 해시 맵과 동일하나 사용하기 더 편리하다.
{: .prompt-general }

```cpp
int findLongestSubstring(string s, int k) {
    unordered_map<char, int> counts;
    int left = 0, ans = 0;
    
    for (int right = 0; right < s.size(); right++) {
        counts[s[right]]++;
        while (counts.size() > k) {
            counts[s[left]]--;
            if (counts[s[left]] == 0) {
                counts.erase(s[left]);
            }
            left++;
        }
        
        ans = max(ans, right - left + 1);
    }
    
    return ans;
}
```

위 코드에서는 해시 맵을 활용해 원하는 키의 빈도를 저장한다. 이렇게 하면 여러 요소에 제약 조건이 있는 슬라이딩 윈도우 문제를 해결할 수 있다. 슬라이딩 윈도우 문제의 시간 복잡도는 대개 각 for 루프 반복 내에서 수행되는 작업의 복잡도가 일정할 때 $$O(n)$$이다. 이 경우에는 해시 맵이 $$O(1)$$ 연산을 제공하기 때문에 해당된다. 이 알고리즘은 해시 맵의 크기가 $$k$$ 이상으로 커지면 요소를 삭제하기 때문에, 해시 맵은 $$O(k)$$의 공간을 차지한다.

---

> **예제 2**: [여러 배열의 교차](https://leetcode.com/problems/intersection-of-multiple-arrays/)
>
> 고유한 정수로 구성된 `n`개의 배열이 포함된 2D 배열 `nums`가 주어질 때, n개의 모든 배열에 나타나는 모든 숫자를 포함하는 정렬된 배열을 반환한다.
>
> 예를 들어 `nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]`인 경우 `[3, 4]`를 반환한다. `3`과 `4`는 모든 배열에 있는 유일한 숫자이다.
{: .prompt-general }

이 문제에서는 각각의 배열에 **고유한** 정수가 포함되어 있다고 가정한다. 따라서 숫자가 모든 배열에 나타나려면 `n`번 나타나야 한다.

해시 맵 `counts`를 활용하여 요소의 빈도를 계산해보자. 각 내부 배열을 반복하며 모든 요소의 `counts`를 업데이트한다. 모든 배열을 확인한 후 해시 맵을 반복하여 어떤 숫자가 `n`번 나타나는지 확인한다.

```cpp
class Solution {
public:
    vector<int> intersection(vector<vector<int>>& nums) {
        unordered_map<int, int> counts;
        for (vector<int>& arr: nums) {
            for (int x: arr) {
                counts[x]++;
            }
        }
        
        int n = int(nums.size());
        vector<int> ans;
        for (auto [key, val]: counts) {
            if (val == n) {
                ans.push_back(key);
            }
        }
        
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

이 문제는 해시 맵의 중요성을 잘 보여준다. 키가 정수일 때 해시 맵 대신 배열을 사용할 수 있을 것 같지만, 배열은 최소한 최대 요소만큼의 크기를 가져야 한다는 문제점이 있다. 예를 들어 `[1, 2, 3, 1000]`과 같은 입력이 주어진다면, 실제로는 인덱스 중 몇 개만 사용되더라도 `1000` 크기의 배열을 초기화해야 한다. 이런 이유로 배열은 많은 공간을 낭비할 수 있다. 해시 맵은 이와 같은 문제점을 해결하며, 입력에 큰 숫자가 포함되어 있어도 문제 없이 처리한다.

리스트가 있고 각 리스트의 평균 요소 수가 m개라고 가정하면, 해시 맵을 구성하는 데 $$O(n⋅m)$$의 시간이 소요된다. 그리고 정렬하는 데는 최악의 경우 $$O(m \cdot \log{}m)$$의 시간이 소요된다. 따라서 전체 시간 복잡도는 $$O(m \cdot (n + \log{}m))$$이다. 모든 입력 요소가 고유하다면, 해시 맵의 크기는 $$n \cdot m$$이며 이는 알고리즘의 공간 복잡도가 O(n \cdot m)임을 의미한다.

---

> **예제 3**: [모든 문자의 발생 횟수가 동일한지 확인](https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/)
>
> 문자열 `s`가 주어졌을 때, 모든 문자가 동일한 빈도로 나타나는지 확인한다.
>
> 예를 들어, `s = "abacbc"`인 경우 모든 문자가 두 번 나타나므로 true를 반환한다. `s = "aaabb"`인 경우 `"a"`는 3번, `"b"`는 2번 나타나므로 `3 != 2`는 같지 않으므로 false를 반환한다.
{: .prompt-general }

해시 맵과 집합을 활용하면 이 문제를 간단히 해결할 수 있다. 해시 맵을 이용하여 문자열 s 내의 각 문자의 발생 `counts`를 계산한다. 모든 문자 `s`의 발생 빈도가 동일한지 확인한다.

집합은 중복을 제거하기 때문에 발생 빈도를 집합에 넣어서 그 크기가 `1`인지 확인하면 모든 문자의 발생 빈도가 동일한지 알 수 있다.

```cpp
class Solution {
public:
    bool areOccurrencesEqual(string s) {
        unordered_map<char, int> counts;
        for (char c: s) {
            counts[c]++;
        }
        
        unordered_set<int> frequencies;
        for (auto [key, val]: counts) {
            frequencies.insert(val);
        }
        
        return frequencies.size() == 1;
    }
};
```

$$n$$을 문자열 `s`의 길이라고 가정하면, 해시 맵을 작성하는 데 $$O(n)$$의 시간이 걸리고, 해시 맵의 값을 집합으로 변환하는 데에도 $$O(n)$$의 시간이 소요된다. 따라서 전체 시간 복잡도는 $$O(n)$$이다. 해시 맵과 집합이 차지하는 공간 복잡도는 유일한 문자의 수와 동일하다. 일부는 영어 알파벳의 문자들이 한정적이라고 주장하여 공간 복잡도를 $$O(1)$$이라고 볼 수도 있지만, 일반적으로 공간 복잡도는 $$O(k)$$로 볼 수 있다. 여기서 $$k$$는 가능한 문자의 수로, 이 문제의 경우에는 최대 26이다.

Python의 collections 모듈에서 제공하는 [Counter](https://docs.python.org/3/library/collections.html#collections.Counter)를 사용한 파이썬 예제:

```py
from collections import Counter

class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        return len(set(Counter(s).values())) == 1
```

---

## **정확한 합을 갖는 부분 배열의 개수 구하기**

1장의 슬라이딩 윈도우에서 "제약 조건을 만족하는 부분 배열/부분 문자열의 개수 찾기"에 대해 소개했다. 이 문제에서는 `left`와 `right` 사이에 있는 윈도우가 제약 조건을 만족하면, `left < x <= right` 범위 내에서 `x`부터 `right`까지의 모든 윈도우도 제약 조건을 만족해야 한다는 것을 나타낸다.

여기서는 그보다 엄격한 제약 조건이 포함된 문제를 다룬다.

> 예를 들면, 입력이 **양수**만 있는 경우 "합계가 k보다 작은 부분 배열의 개수 구하기"는 슬라이딩 윈도우를 사용해 해결할 수 있다. 이번 섹션에서는 "합이 k와 **정확히 동일한** 부분 배열의 개수 구하기" 문제에 대해 다룬다.
{: .prompt-general }

초기에 이런 문제들은 매우 어려워 보일 수 있다. 하지만 패턴을 익히면 훨씬 간단해진다. 이 패턴에 해당하는 문제들의 코드가 매우 유사하다는 것도 알게 될 것이다. 이 알고리즘을 이해하기 위해서는 누적 합의 개념을 알아야 한다.

누적 합을 활용하면 두 누적 합의 차이를 이용해 부분 배열의 합을 찾을 수 있다. 합이 `k`와 정확히 같은 부분 배열을 찾기 원하고, 입력에서 누적 합을 얻을 수 있다면, 누적 합이 `k`와 같을 때 해당 부분 배열의 합이 `k`와 같다는 것을 알 수 있다. 그렇다면 이 차이를 어떻게 찾을 수 있을까?

먼저 누적 합을 발생 빈도와 연결하는 해시 맵 `counts`를 만든다. 예를 들면, 입력에 음수가 있을 경우 동일한 누적 합이 여러 번 나타날 수 있다. `nums = [1, -1, 1]`의 경우 누적 합은 `[1, 0, 1]`로, `1`이 두 번 나타난다. `counts[0] = 1`로 초기화해야 한다. 이는 `빈 배열`의 합이 `0`이기 때문이다. 이 부분의 중요성은 뒤에 설명하겠다.

다음으로 답 변수와 `curr`를 선언한다. 입력을 순회하면서 `curr`은 지금까지의 합을 나타낸다.

입력을 순회하면서 `curr`를 업데이트하고 `curr`의 발생 `빈도(counts)`를 1씩 증가시킨다. 그러나 `counts`를 업데이트하기 전에 답을 먼저 업데이트해야 한다.

답을 어떻게 업데이트할까? 슬라이딩 윈도우 방식에서 '부분 배열의 수'를 찾을 때 각 인덱스에 집중하여 현재 인덱스에서 **끝나는** 유효한 부분 배열의 수를 알아냈었다. 여기서도 같은 방식을 적용한다. 인덱스 `i`에 있다고 가정하면, 지금까지의 합이 `curr`이고, `counts` 내에 `i` 이전의 모든 누적 합이 저장되어 있다. 따라서 부분 배열의 합이 `k`인 경우, `i`에서 끝나려면 이전에 `curr - k`의 값을 가진 누적 합이 **반드시** 있어야 한다.

부분 배열의 합을 구할 때 두 누적 합의 차이를 이용한다는 것을 기억하자. `curr - k`의 누적 합이 이미 있고 현재 누적 합이 `curr`라면, 이 두 누적 합의 차이는 k이며, 우리가 찾는 값이다(`curr - (curr - k) = k`).

그러므로 `counts[curr - k]` 만큼 답을 증가시킨다. 만약 `curr - k`의 누적 합이 음수 때문에 이전에 여러 번 발생했다면, 해당 누적 합을 시작점으로 하여 현재 인덱스에서 끝나는 서브 배열들 중 합이 `k`인 배열들을 만들 수 있다. 그러므로 발생 빈도를 추적하는 것이 필요하다.

---

> **예제 4**: [부분 배열의 합계가 k와 같은 경우](https://leetcode.com/problems/subarray-sum-equals-k/)
>
> 정수 배열 `nums`와 정수 `k`가 주어졌을 때, 그 합이 `k`와 같은 부분 배열의 개수를 구해보자.
{: .prompt-general }

예제를 통해 위에서 설명한 알고리즘이 이 문제에 적합한 이유를 살펴보자. `nums = [1, 2, 1, 2, 1], k = 3`이라고 가정하면, 합계 `3`인 `[1, 2]`가 두 번, `[2, 1]` 이 두 번인 4개의 부분 배열이 있다.

이 입력의 누적 합계, 즉 반복 중에 curr이 나타내는 값은 `[1, 3, 4, 6, 7]`이다. 이 `3`의 배열에는 `(4 - 1)`, `(6 - 3)`, `(7 - 4)`의 세 가지 차이점이 있다.

하지만 유효한 부분 배열이 네 개라고 했으므로, 비어 있는 접두사를 고려해 해시 맵을 `0: 1`로 초기화해야 한다. 합이 k와 같은 접두사가 있으면 `0: 1`로 초기화하지 않으면 `curr - k = 0`이 해시 맵에 표시되지 않아 유효한 부분 배열을 "잃게" 된다.

따라서 인덱스 1, 2, 3, 4에서 `curr - k`가 이전에 나타났음을 확인할 수 있다. 요소는 모두 양수이므로 `curr - k`의 각 값은 한 번만 나타나므로 결과는 `4`이다.

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> counts;
        counts[0] = 1;
        int ans = 0, curr = 0;
        
        for (int num: nums) {
            curr += num;
            ans += counts[curr - k];
            counts[curr]++;
        }
        
        return ans;
    }
};
```

이 예에서는 배열에 양수만 있다면 집합을 사용하면 되는데, 제약 조건에 따라 `-1000 <= nums[i] <= 1000`이므로 `nums = [1, -1, 1, -1], k = 0`인 경우를 생각해야 한다. 유효한 부분 배열은 네 개: `[1, -1]` 두 번, `[-1, 1]` 한 번, 그리고 전체 배열 `[1, -1, 1, -1]`이다.

누적 합은 `[1, 0, 1, 0]`이다. 최종 인덱스인 `[1, -1]`과 전체 배열에서 끝나는 두 개의 부분 배열이 있다. `counts[0] = 1`로 초기화하므로 두 번째 인덱스 뒤에는 `counts[0] = 2`가 되며, 최종 인덱스에 도달하여 `ans += counts[curr - k] = ans += counts[0]`을 수행하면 두 부분 배열을 모두 결과에 추가한다. 입력에 양수만 있는 것이 아니므로 **동일한 접두사가 여러 번 나타날** 수 있어 해시 맵이 필요하다.

알고리즘의 시간 및 공간 복잡도는 모두 $$O(n)$$이며, 여기서 $$n$$은 `nums`의 길이이다.

---

> **예제 5**: [깔끔한 부분 배열 개수 계산](https://leetcode.com/problems/count-number-of-nice-subarrays/)
>
> 양의 정수 배열 `nums`와 정수 `k`가 주어진다. 정확히 `k`개의 홀수가 포함된 부분 배열의 수를 구하라.
>
> 예를 들어 `nums = [1, 1, 2, 1, 1], k = 3`이라면, 결과는 `2`이다. 홀수가 `3`개인 부분 배열은 `[1, 1, 2, 1, 1]` 및 `[1, 1, 2, 1, 1]`이다.
{: .prompt-general }

이전 예제에서 제약 조건은 합계였다. 하지만 이 문제에서는 **홀수의 개수**가 제약 조건이다. 따라서 `curr`는 홀수의 개수를 추적하게 된다.

> 홀수인지 확인하기 위해선 숫자를 2로 나누면 된다. `x`가 홀수라면 `x % 2 = 1`이다.
{: .prompt-general }

```cpp
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        unordered_map<int, int> counts;
        counts[0] = 1;
        int ans = 0, curr = 0;
        
        for (int num: nums) {
            curr += num % 2;
            ans += counts[curr - k];
            counts[curr] += 1;
        }
        
        return ans;
    }
};
```

"이 패턴에 속하는 각 문제의 코드가 얼마나 비슷한지 알 수 있을 것"이라고 말씀드렸던 것을 기억하는가? 두 가지 다른 문제와 코드의 차이는 **말 그대로** "`% 2`"라는 두 글자뿐이다. 다음 몇 가지 연습 문제를 직접 풀어보면서 이 글에서 배운 지식을 적용해 보자.

이 패턴에 속하는 각 문제의 코드는 매우 비슷하다. 두 문제의 코드 차이는 단지 "% 2" 두 글자 뿐이다. 이 지식을 활용하여 다양한 문제를 해결해보자. 이 알고리즘의 시간 및 공간 복잡도는 이전 문제와 동일하게 $$O(n)$$이다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/705/hashing/4512/)
