---
title: "치트 시트"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-10 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

이 글은 문제를 해결하고 면접을 준비하면서 사용할 수 있는 치트시트 모음집이 될 것이다. 여기서 다음을 찾을 수 있다:

- 시간 복잡도 (Big O) 치트 시트
- 일반적인 자료 구조/알고리즘 플로우 차트 (각 자료 구조/알고리즘이 사용되는 시기)
- 면접 단계별 치트 시트

---

## **시간 복잡도(Big O) 치트 시트**

![CheetSheet](cheetsheet.png)

먼저, 자료 구조/알고리즘별로 나눠진 일반적인 작업의 시간 복잡도에 대해 이야기해보겠다. 그 다음, 입력 크기에 주어진 합리적인 복잡도에 대해 논의할 것이다.

배열 (동적 배열/리스트)

`n = arr.length`라고 할 때,

- 끝에 요소 추가 또는 제거: $$O(1)$$ 평균
- 임의의 인덱스에서 요소 추가 또는 제거: $$O(n)$$
- 임의의 인덱스에서 요소 접근 또는 수정: $$O(1)$$
- 요소가 있는지 확인: $$O(n)$$
- 투 포인터: $$O(n \cdot k)$$, 여기서 k는 각 반복에서 수행되는 작업이며 슬라이딩 윈도우를 포함한다.
- 접두사 합 만들기: $$O(n)$$
- 접두사 합이 주어진 경우 부분 배열의 합 찾기: $$O(1)$$

---

## **문자열 (불변)**

`n = s.length`라고 할 때,

- 문자 추가 또는 제거: $$O(n)$$
- 임의의 인덱스에서 요소 접근: $$O(1)$$
- 두 문자열 사이의 연결: $$O(n + m)$$, 여기서 $$m$$은 다른 문자열의 길이
- 부분 문자열 생성: $$O(m)$$, 여기서 $$m$$은 부분 문자열의 길이
- 투 포인터: $$O(n \cdot k)$$, 여기서 $$k$$는 각 반복에서 수행되는 작업이며 슬라이딩 윈도우를 포함한다.
- 배열, 문자열 빌더 등을 결합하여 문자열 만들기: $$O(n)$$

---

## **링크드 리스트**

$$n$$이 링크드 리스트의 노드 수라고 할 때,

- 추가/제거 위치 이전에 포인터가 주어진 경우 요소 추가 또는 제거: $$O(1)$$
- 추가/제거 위치에 포인터가 주어진 경우 요소 추가 또는 제거: $$O(1)$$ (이중 링크드 리스트인 경우)
- 포인터 없이 임의의 위치에 요소 추가 또는 제거: $$O(n)$$
- 포인터 없이 임의의 위치에서 요소 접근: $$O(n)$$
- 요소가 있는지 확인: $$O(n)$$
- `i`와 `j` 사이의 위치를 반전: O(j−i)
- 순환 찾기: $$O(n)$$ (빠른-느린 포인터 또는 해시 맵 사용)

---

## **해시 테이블/딕셔너리**

n = dic.length라고 할 때,

- 키-값 쌍 추가 또는 제거: $$O(1)$$
- 키가 있는지 확인: $$O(1)$$
- 값이 있는지 확인: $$O(n)$$
- 키와 관련된 값 접근 또는 수정: $$O(1)$$
- 모든 키, 값 또는 둘 다에 대해 반복: $$O(n)$$

> 참고: $$O(1)$$ 작업은 n에 상대적인 상수이다. 실제로는, 해싱 알고리즘이 비싸다. 예를 들어, 키가 문자열인 경우 문자열의 길이인 m에 대해 $$O(m)$$의 비용이 든다. 작업은 해시 맵의 크기에 상대적으로 상수 시간이 걸린다.
{: .prompt-general }

---

## **집합 (Set)**

`n = set.length`라고 할 때,

- 요소 추가 또는 제거: $$O(1)$$
- 요소가 있는지 확인: $$O(1)$$

> 위의 참고 사항도 여기에 적용된다.
{: .prompt-general }

---

## **스택**

스택 작업은 해당 구현에 따라 다르다. 스택은 pop과 push를 지원하는 것만으로 충분하다. 동적 배열로 구현된 경우:

`n = stack.length`라고 할 때,

- 요소 푸시: $$O(1)$$
- 요소 팝: $$O(1)$$
- 피크(스택의 맨 위의 요소 보기): $$O(1)$$
- 임의의 인덱스에서 요소 접근 또는 수정: $$O(1)$$
- 요소가 존재하는지 확인: $$O(n)$$

---

## **큐**

큐 작업은 해당 구현에 따라 다르다. 큐는 dequeue와 enqueue를 지원하는 것만으로 충분하다. 이중 링크드 리스트로 구현된 경우:

`n = queue.length`라고 할 때,

- 요소 Enqueue: $$O(1)$$
- 요소 Dequeue: $$O(1)$$
- Peek(큐의 맨 앞의 요소 보기): $$O(1)$$
- 임의의 인덱스에서 요소 접근 또는 수정: $$O(n)$$
- 요소가 존재하는지 확인: $$O(n)$$

> 참고: 대부분의 프로그래밍 언어에서 큐는 단순 이중 링크드 리스트보다 더 복잡한 방식으로 구현한다. - 구현에 따라 인덱스별 요소 접근이 $$O(n)$$보다 빠를 수 있지만 상수 나누기가 큰 경우도 있다.
{: .prompt-general }

---

## **이진 트리 문제 (DFS/BFS)**

트리의 노드 수를 $$n$$이라고 할 때,

대부분의 알고리즘은 각 노드에서 수행되는 작업이 보통 $$O(1)$$인 $$k$$에 대해 $$O(n \cdot k)$$ 시간이 걸린다. 이는 단순한 일반 규칙일 뿐 항상 그렇지는 않다. 여기서는 BFS가 효율적인 큐로 구현되었다고 가정한다.

---

## **이진 탐색 트리**

트리의 노드 수를 n이라고 할 때,

- 요소 추가 또는 제거: 최악의 경우 $$O(n)$$, 평균적으로 $$O(\log{}n)$$
- 요소 존재 확인: 최악의 경우 $$O(n)$$, 평균적으로 $$O(\log{}n)$$

트리가 잘 균형을 이루고 있을 때 평균적인 경우이다 - 각 깊이가 거의 가득 차 있음. 최악의 경우는 트리가 그냥 직선인 경우이다.

---

## **힙/우선 순위 큐**

힙의 길이를 n이라고 하고 최소 힙에 대해 말할 때,

- 요소 추가: $$O(\log{}n)$$
- 최솟값 삭제: $$O(\log{}n)$$
- 최솟값 찾기: $$O(1)$$
- 요소 존재 확인: $$O(n)$$

---

## **이진 탐색**

최악의 경우 이진 탐색은 검색 공간의 크기인 $$n$$에 대해 $$O(\log{}n)$$에 실행된다.

---

## **기타**

- 정렬: 정렬되는 데이터의 크기인 $$n$$에 대해 $$O(n \cdot \log{}n)$$
- 그래프에서의 DFS와 BFS: 노드 수가 $$n$$이고, 간선 수가 e인 경우, 각 노드를 $$O(1)$$에 처리하면서 간선을 반복하는 경우 $$O(n \cdot k + e)$$
- DFS와 BFS의 공간 복잡도: 일반적으로 $$O(n)$$이지만 그래프에 있을 경우 그래프를 저장하기 위해 $$O(n + e)$$일 수 있다.
- 동적 프로그래밍의 시간 복잡도: 상태 수가 $$n$$이고, 각 상태에서 이뤄지는 작업이 k인 경우 $$O(n \cdot k)$$
- 동적 프로그래밍의 공간 복잡도: 상태 수가 $$n$$인 경우 $$O(n)$$

---

## **입력 크기 대비 시간 복잡도**

문제의 제약 조건을 고려할 때 이것은 단서로 볼 수 있다. 왜냐하면 제약 조건은 해결책의 시간 복잡도가 어디까지인지를 나타내는 상한선을 제시하기 때문이다. 입력 크기를 바탕으로 예상 시간 복잡도를 파악할 수 있는 능력은 소중한 기술이다. 대부분의 온라인 코딩 테스트 사이트에서는 문제의 제약 조건이 주어진다. 불행히도 인터뷰에서는 문제의 제약 조건을 명시적으로 말해주지 않는 경우가 많지만, 그래고 면접에서 예상 입력 크기에 대해 묻는 것은 큰 문제가 되지 않는다.

---

### n <= 10

예상되는 시간 복잡도는 팩토리얼이나 밑이 2보다 큰 지수 함수일 가능성이 높다 - $$O(n^2 \cdot n!)$$ 또는 $$O(4^n)$$ 예를 들면 이렇다.

백트래킹이나 다른 완전 탐색 유형의 재귀 알고리즘에 대해 생각해봐야 한다. `n <= 10`은 극단적으로 작기 때문에 올바른 답을 찾는 거의 모든 알고리즘이 충분히 빠를 것이다.

---

### 10 < n <= 20

예상되는 시간 복잡도는 대체로 $$O(2^n)$$이다. 그 이상의 밑이나 팩토리얼은 너무 느리다 ($$3^{20}$$ = 대략 35억, 그리고 $$20!$$는 훨씬 크다). $$2^n$$은 주어진 요소 집합에 대해 모든 부분 집합/부분 순열을 고려하는 것을 의미한다 - 각 요소에 대해 두 가지 선택이 있다: 가져가거나 가져가지 않는다.

이 범위도 매우 작으므로 대부분 올바른 알고리즘은 아마 충분히 빠를 것이다. 백트래킹과 재귀를 고려해보자.

---

### 20 < n <= 100

이 시점에서는 지수 함수가 너무 느릴 것이다. 상한선은 아마 $$O(n^3)$$일 것이다.

코딩 테스트 연습 사이트에서 "쉬운"으로 표시된 문제들은 보통 이 범위를 가지고 있는데, 이는 오해의 소지가 있다. $$O(n)$$에서 실행되는 해결책이 있을 수 있지만, 작은 범위는 무차별적인 해결책을 통과시킬 수 있도록 한다(선형 시간 해결책을 찾는 것은 "쉽다"고 간주되지 않을 수 있다).

중첩 루프를 포함하는 강제적인 해결책을 고려하라. 만약 강제적인 해결책을 생각해낸다면, 어떤 단계가 "느린"지 분석하고 해시 맵이나 힙과 같은 도구를 사용하여 그 단계를 개선하려고 시도해보자.

---

### 100 < n <= 1,000

이 범위에서는 이차 시간 복잡도 $$O(n^2)$$가 충분해야 한다, 상수 요소가 너무 크지 않는 한.

이전 범위와 비슷하게 중첩 루프를 고려해야 한다. 이 범위와 이전 범위의 차이점은 $$O(n^2)$$가 보통 이 범위에서 예상되는/최적의 시간 복잡도이며, 개선할 수 없을 수도 있다는 것이다.

---

### 1,000 < n < 100,000

$$n <= 10^5$$은 코딩 테스트 환경에서 볼 수 있는 가장 흔한 제약 조건이다. 이 범위에서 가장 느린 수용 가능한 일반적인 시간 복잡도는 $$O(n \cdot \log{}n)$$이지만, 선형 시간 접근 방식인 $$O(n)$$이 일반적으로 목표이다.

이 범위에서 입력 정렬이나 힙 사용이 도움이 될 수 있는지 스스로에게 물어봐라. 그렇지 않다면 $$O(n)$$ 알고리즘을 목표로 하라. $$O(n^2)$$에서 실행되는 중첩 루프는 받아들여지지 않는다 - 아마도 이 과정에서 배운 기술을 사용하여 $$O(1)$$ 또는 $$O(\log{}n)$$에서 중첩 루프의 행동을 시뮬레이션할 필요가 있을 것이다:

- 해시 맵
- 슬라이딩 윈도우와 같은 두 포인터 구현
- 단조 스택
- 이진 검색
- 힙
- 위의 어떤 조합

$$O(n)$$ 알고리즘이 있다면, 상수 요소는 상당히 커도 된다(약 40 정도). 문자열 문제에 대한 일반적인 테마 하나는 각 반복에서 알파벳 문자를 순환하는 것이며, 이로 인해 시간 복잡도는 $$O(26n)$$이 된다.

---

### 100,000 < n < 1,000,000

$$n <= 10^6$$은 드문 제약이며, $$O(n)$$의 시간 복잡도가 필요할 것이다. 이 범위에서는 $$O(n \cdot \log{}n)$$이 보통 안전하며 작은 상수 요소를 가지고 있어야 한다. 아마도 어떤 방식으로든 해시 맵을 포함해야 할 것이다.

---

### 1,000,000 < n

거대한 입력이 있는 경우, 일반적으로 10^9 이상의 범위에서 가장 흔한 수용 가능한 시간 복잡도는 로그함수 $$O(\log{}n)$$ 또는 상수 $$O(1)$$이 될 것이다. 이 문제들에서는 각 반복에서 검색 공간을 크게 줄이거나(보통 이진 검색) 수학적 방법이나 해시 맵을 영리하게 사용하여 상수 시간에 정보를 찾는 방법을 사용해야 한다.

> $$O(sqrt(n))$$과 같은 다른 시간 복잡도가 가능하지만, 이는 매우 드물며 매우 고급 문제에서만 볼 수 있다.
{: .prompt-general }

---

## **정렬 알고리즘**

모든 주요 프로그래밍 언어에는 내장된 정렬 방법이 있다. 정렬 비용이 $$O(n \cdot \log{}n)$$이라고 가정하고 말하는 것이 일반적으로 정확하다. 여기서 $$n$$은 정렬되는 요소의 수이다. 완전성을 위해, 여기 많은 일반적인 정렬 알고리즘과 그들의 완전성을 나열한 차트가 있다. 프로그래밍 언어에 의해 구현된 알고리즘은 다양하다. 예를 들어, 파이썬은 Timsort를 사용하지만 C++에서는 특정 알고리즘이 지정되지 않고 다양하다.

![sort_algorithm_cheet](sort_algorithm_cheet.png)

> [Wikipedia](https://en.wikipedia.org/wiki/Category:Stable_sorts)에서 안정 정렬의 정의: "안정 정렬 알고리즘은 동일한 키(즉, 값)를 가진 레코드의 상대적인 순서를 유지한다. 즉, 정렬 알고리즘이 안정적이라는 것은 원래 리스트에서 R이 S 앞에 나타나는 동일한 키를 가진 두 레코드 R과 S가 있을 때, 정렬된 리스트에서 R이 S 앞에 나타난다는 것이다."
{: .prompt-general }

---

## **일반 DS/A 플로우차트**

어떤 자료 구조나 알고리즘이 사용되어야 하는지 파악할 수 있게 도와주는 플로우차트가 있다. 이 플로우차트는 모든 시나리오를 커버하기는 불가능하기 때문에 매우 일반적이라는 점을 유의하라.

> 이 플로우차트는 LICC에서 가르치는 방법만을 다루며, 따라서 Dijkstra와 같은 더 고급 알고리즘은 제외된다.
{: .prompt-general }

![cheet_sheet_array](cheet_sheet_array.png)

---

## **인터뷰 단계별 요약**

다음은 앞의 글, "인터뷰의 단계" 기사의 요약이 될 것이다. 화상 면접이 있다면, 이 요약된 버전을 인쇄하여 인터뷰 중 앞에 두고 참고해보자.

### 단계 1: 소개

- 교육, 직장 경험, 관심사에 대한 30-60초의 준비된 소개가 있어야 한다.
- 미소를 짓고 자신감을 가지고 말해야 한다.
- 면접관이 자신에 대해 말할 때 주의를 기울이고 나중에 그들의 작업을 질문에 포함시키자.

### 단계 2: 문제 설명

- 면접관이 문제를 읽은 후에 문제를 다시 말해줘서 이해했는지 확인해보자.
- 입력에 대한 명확한 질문을 하라. 예상되는 입력 크기, 엣지 케이스, 유효하지 않은 입력 등이다.
- 문제를 이해했는지 확인하기 위해 빠르게 테스트 케이스 예제를 거쳐가자.

### 단계 3: DS&A 브레인스토밍

- 항상 크게 생각하며 말하라.
- 문제를 분할하라: 무엇을 해야 하는지 파악하고, 어떤 자료 구조나 알고리즘이 좋은 시간 복잡도로 그것을 달성할 수 있는지 생각해보자.
- 면접관의 모든 코멘트나 피드백에 대해 수용적이 되어야 한다. 그들은 아마 올바른 해결책을 향해 너를 이끌려고 시도할 것이다.
- 아이디어가 있다면, 코딩하기 전에 면접관에게 아이디어를 설명하고 그것이 합리적인 접근법이라고 이해하고 동의하는지 확인해보자.

### 단계 4: 구현

- 구현하는 동안 결정 과정을 설명해야 한다. 예를 들어 세트를 선언할 때, 그 목적이 무엇인지 설명해야 한다.
- 프로그래밍 언어의 관례에 맞는 깔끔한 코드를 작성해야 한다.
- 중복 코드를 작성하지 않도록 주의해야 한다. 비슷한 코드를 여러 번 작성하는 경우, 도우미 함수나 for 루프를 사용해야 한다.
- 막히는 부분이 있다면 당황하지 않고 면접관과 의사소통해야 한다.
- 무서워하지 말고 무식한 방법으로 해결책을 시작해야 한다(그렇다고 인정하면서), 그 다음 "느린" 부분을 최적화하여 개선해야 한다.
- 생각을 계속해서 말하며 면접관과 대화해야 한다. 그러면 그들이 힌트를 주기 쉬워진다.

### 단계 5: 테스팅 & 디버깅

- 테스트 케이스를 진행할 때, 파일 하단에 변수를 기록하며 지속적으로 업데이트해야 한다. 접두사 합계를 만드는 등 사소한 부분은 요약해서 시간을 절약해야 한다.
- 오류가 있고 코드를 실행할 수 있는 환경이라면, 알고리즘에 print 문을 넣고 작은 테스트 케이스를 사용하여 변수의 예상 값과 실제 값이 일치하는지 비교해야 한다.
- 문제에 부딪히면 면접관과 계속 대화를 유지해야 한다.

### 단계 6: 설명 및 후속 조치

준비해야 할 질문들:

- 시간 및 공간 복잡도, 평균 및 최악의 경우.
- 왜 이 자료 구조, 알고리즘, 또는 논리를 선택했는가?
- 복잡도 면에서 알고리즘을 개선할 수 있다고 생각하는가? 이 질문을 받으면, 대개의 경우 답은 `예`이며, 특히 알고리즘이 $$O(n)$$보다 느릴 때 그렇다.

### 단계 7: 마무리

- 회사에 대해 준비된 질문이 있어야 한다.
- 관심을 갖고, 미소를 지으며, 면접관의 답변에 후속 질문을 해야 한다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/713/interviews-and-tools/4547/)

<!--

{: .prompt-general }

-->