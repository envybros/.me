---
title: "비트 조작"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-12 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

비트 조작은 알고리즘의 복잡성을 영리한 방법으로 개선할 수 있는 강력한 도구다. 비트 조작은 데이터를 이진 형태로 보고 이 형태에서 "비트"를 조작하는 것을 포함한다. 알아야 할 가장 중요한 연산은 다음과 같다:

1. OR `|`
        - 어떤 비트라도 `1`이면 결과는 `1`이 될 것이다. 그렇지 않으면 결과는 `0`이다.
2. AND `&`
        - 모든 비트가 `1`이면 결과는 `1`이다. 그렇지 않으면 결과는 `0`이다.
3. XOR `^`
        - `1` 비트의 수가 홀수면 결과는 `1`이다. 그렇지 않으면 결과는 `0`이다.
4. 왼쪽 및 오른쪽 시프트: `<<`, `>>`
        - 시프트는 모든 비트를 각각의 방향으로 한 자리 이동시킨다. 첫 번째 비트가 뒤집히면 오른쪽 시프트는 그것을 "삭제"할 것이다.
        - 시프트는 숫자를 2로 곱하거나 나누는 것과 일치한다. (왼쪽 시프트 = 2로 곱하기, 오른쪽 시프트 = 2로 나누기의 내림)

정수에 대해 비트 조작을 수행하고 있고, 두 정수 `x, y`가 있다고 가정해보자. `x`와 `y`에 이러한 연산을 수행하면 연산은 모든 비트에 적용된다. 예를 들어

`x = 15` 그리고 `y = 12`, 그러면 이진수로, `x = 1111` 그리고 `y = 1100`.

`x | y = 1111 = 15`

`x & y = 1100 = 12`

`x ^ y = 0011 = 3`

`x << 1 = 11110 = 30`

`x >> 1 = 111 = 7`

때로는 숫자의 모든 비트보다 특정 비트에 초점을 맞추고 싶을 수 있다. 이를 위해 **비트마스크**라고 불리는 것을 사용할 수 있다. 하나의 비트가 뒤집힌 **마스크**는 다른 숫자의 개별 비트를 확인하는 데 사용될 수 있다. 예를 들어, 우리가 숫자 `x`의 두번째 비트(오른쪽에서 0으로 인덱싱되어, 10진수 `4`를 나타내는 비트)에만 관심이 있다고 가정해보자.

정수 `mask = 1`을 가지고 왼쪽으로 두 번 시프트하여 두번째 위치(`100`)에 있도록 한 다음, 이제 `x`와 mask 사이의 모든 연산은 두번째 비트에만 "적용"된다.

`x`의 두번째 비트가 뒤집어져 있는지 확인하려면 `mask & x`를 수행할 수 있다. 마스크의 모든 비트가 두번째 비트 외에는 `0`이므로 이 결과는 `x`의 두번째 비트가 뒤집히지 않은 경우에만 `0`이 될 것이다. 이는 `mask & x`의 결과가 `x`의 `2`번째 비트가 뒤집힌 경우에만 `0`이 아니라는 것을 의미한다.

`x`의 두번째 비트를 뒤집으려면 `mask ^ x`를 수행할 수 있다. 마스크의 모든 비트가 두번째 비트 외에는 `0`이므로 XOR 연산은 다른 비트를 변경하지 않는다. `x`의 두번째 비트가 `1`이면, 그러면 `1 ^ 1 = 0`이다. `0`이면 `1 ^ 0 = 1`이다.

> XOR에 대해 생각하는 쉬운 방법: `x XOR 0`을 하면 x는 변하지 않는다. `x XOR 1`을 하면 `x`는 뒤집힌다.
{: .prompt-general }

---

## **예제: 단일 번호**

> [문제 링크](https://leetcode.com/problems/single-number/)
>
> 정수 `nums`의 비어 있지 않은 배열이 주어지며, 각 요소는 하나를 제외하고 두 번 나타난다. 그 하나를 찾아보자.
{: .prompt-general }

처음 생각할 수 있는 것은 해시 맵을 사용하여 각 요소의 빈도를 계산한 다음 한 번만 나타나는 요소를 찾는 것일 것이다. 이것은 배열의 길이인 $$n$$에 대한 시간 및 공간 복잡성이 $$O(n)$$이 될 것이다.

공간 복잡성을 개선하기 위해, `nums`를 정렬한 다음 반복하여 두 번 나타나지 않는 요소를 확인할 수 있다. 사용하는 언어의 정렬 구현에 따라, 이것은 공간 복잡성을 $$O(n)$$ 아래로 낮출 수 있지만, 시간 복잡성은 $$O(n \cdot \log{}n)$$이 된다.

XOR 연산이 무엇을 하는지 다시 상기해라: "`1` 비트의 수가 홀수면 결과는 `1`이다. 그렇지 않으면 결과는 `0`이다". 우리가 찾고 있는 숫자는 홀수 번(한 번) 나타나는 유일한 숫자다.

마스크를 만들고 배열의 모든 요소와 XOR할 수 있다. 다른 모든 숫자가 두 번 나타나기 때문에, 그들은 서로를 취소할 것이고, 답이 되지 않는 유일한 숫자가 답이 될 것이다.

> XOR 속성: `x XOR x = 0`이고 `0 XOR y = y`. 따라서 `x XOR x XOR y = y`.
>
> 입력에서 `x XOR x`의 여러 인스턴스가 있을 것이고, 이 모든 것은 `0`이 될 것이다. 이 모든 `0`이 서로 XOR되면 역시 `0`이 되며, 최종적으로 남는 것은 `0 XOR y = y`일 것이다. XOR을 수행하는 순서는 중요하지 않기 때문에 이 알고리즘이 작동한다.
{: .prompt-general }

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int mask = 0;
        for (int num: nums) {
            mask ^= num;
        }
        
        return mask;
    }
};
```

이로 인해 $$O(n)$$ 시간과 $$O(1)$$ 공간의 알고리즘이 만들어진다. 실질적으로 이 알고리즘은 정수 및 비트 연산이 매우 빠르기 때문에 해시 맵 접근 방식보다 더 빠르다. 해시 맵에는 오버헤드가 있다.

---

## **비트마스크를 "방문한" 상태의 해시 가능 표시로 사용하기**

백트래킹과 DP 문제에서, 배열의 요소를 최대 한 번만 사용하는 문제를 보았다. 이런 문제가 있을 때 사용한 요소의 지표가 있으면 유용하다. `arr[i]`가 $$i$$번째 요소가 사용되었는지를 나타내는 부울인 배열을 사용할 수 있다. 문제는 배열을 해시할 수 없기 때문에 상태를 메모이제이션해야 하는 DP 문제에서 실현 가능한 해결책이 아니다. 해시할 수 있는 튜플을 사용할 수 있지만, 상태 변경마다 튜플을 수정하는 것은 비용이 많이 들고, 일반적으로 깔끔하지 않다. 비트마스크가 최선의 옵션이다 - 정수 `마스크`를 가지고 있고 $$i$$번째 비트가 $$i$$번째 요소가 사용되었다면 뒤집힌다고 가정해보자. 우리는 XOR을 사용하여 요소를 "사용"할 때 비트를 뒤집을 수 있고, AND를 사용하여 요소가 사용되었는지 확인할 수 있다. 예를 들어 살펴보자:

### 예제: N-Queen II

> [문제 링크](https://leetcode.com/problems/n-queens-ii/)
>
> 백트래킹 챕터에서의 이 문제를 기억하는가? 우리는 같은 알고리즘을 사용하지만 세트 대신 비트마스크를 사용하여 다시 해결할 것이다. 이것은 공간 사용량을 개선한다(그리고 세트가 더 많은 오버헤드를 가지기 때문에 시간도 개선).
{: .prompt-general }

이전 해결책에서, 우리는 `[0, n)`에서 열을 저장하기 위해 세트를 사용했다. $$i$$번째 열이 사용되었는지 확인하기 위해 세트를 사용하는 대신, $$i$$번째 비트가 $$i$$번째 열이 사용되었다면 `1`인 정수 cols를 사용할 수 있다.

$$i$$번째 비트를 확인하려면, `currCol = 1 << i` 같은 마스크를 사용할 수 있다. 이것은 `001000`과 같은 이진 숫자가 될 것이다. 오직 $$i$$번째 비트만 설정되어 있기 때문에, cols에 대한 AND 연산을 수행하면 cols에도 $$i$$번째 비트가 설정되어 있을 경우에만 0이 아닐 것이다.

결과가 0이면, 그것은 `cols`에 해당 비트가 설정되지 않았음을 의미하며, 이는 우리가 열에 퀸을 놓을 수 있다는 것을 의미한다. 퀸을 놓기 위해서는 $$i$$번째 비트만 1로 변경해야 하는데, 이것은 `cols ^ currCol`의 결과일 것이다. 퀸을 제거할 때, 같은 연산이 이를 취소할 것이다.

우리는 대각선과 반대 대각선에 대해서도 정확히 같은 논리를 사용할 수 있다. 하나 주의할 점: 우리는 음수 비트 시프트를 할 수 없고, 대각선의 경우 `row - col`이 음수가 될 수 있기 때문에 음수가 되지 않도록 상수 `n`을 더해야 한다.

> 참고: 비트 조작 연산은 낮은 우선 순위를 가진다(PEMDAS/BEDMAS를 생각해보자). 비트 연산을 사용할 때는 괄호`()`를 사용하여 용어를 매우 명확하게 정의하는 것이 좋다.
{: .prompt-general }

```cpp
class Solution {
public:
    int n;
    
    int totalNQueens(int n) {
        this->n = n;
        return backtrack(0, 0, 0, 0);
    }
    
    int backtrack(int row, int diagonals, int antiDiagonals, int cols) {
        // Base case - N개의 퀸이 배치됨
        if (row == n) {
            return 1;
        }
        
        int solutions = 0;
        for (int col = 0; col < n; col++) {
            int currDiagonal = 1 << (row - col + n); // 음수를 피하기 위해 n을 더함
            int currAntiDiagonal = 1 << (row + col);
            int currCol = 1 << col;
            
            // 퀸을 배치할 수 없는 경우
            if (cols & currCol || 
                diagonals & currDiagonal || 
                antiDiagonals & currAntiDiagonal) {
                continue;
            }

            // 퀸을 보드에 "추가"
            cols ^= currCol;
            diagonals ^= currDiagonal;
            antiDiagonals ^= currAntiDiagonal;

            // 업데이트된 보드 상태로 다음 행으로 이동
            solutions += backtrack(row + 1, diagonals, antiDiagonals, cols);
            
            // 위 함수 호출을 사용하여 모든 유효한 경로를 이미 탐색했기 때문에
            // 보드에서 퀸을 "제거"
            cols ^= currCol;
            diagonals ^= currDiagonal;
            antiDiagonals ^= currAntiDiagonal;
        }
        
        return solutions;
    }
};
```

이제 3개의 집합을 사용하는 대신에 3개의 정수를 가지고 있다. 호출 스택 때문에 공간 복잡도는 여전히 $$O(n)$$이지만, 실질적으로는 공간 사용을 개선했다. 비트 조작 연산도 매우 빠르다. 반면, 집합은 해싱과 관련된 오버헤드가 있다.

배열이나 집합 대신 비트마스크를 사용하여 "방문한" 상태를 표시하는 것의 큰 장점 중 하나는 정수가 불변하기 때문에 해시할 수 있으며, 따라서 함수를 메모이제이션할 수 있다는 것이다. 이를 통해 많은 문제들을 동적 프로그래밍으로 깔끔하게 해결할 수 있다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/714/bonus/4550/)

<!--

{: .prompt-general }

-->