---
title: "해싱 (Hashing)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-11 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

이 장을 시작하기 전에 자료 구조에 대한 기본적인 내용을 알아보자.

자료 구조란 데이터를 효율적으로 구성하기 위한 방식을 의미한다. 자료 구조는 크게 인터페이스와 구현의 두 부분으로 나뉜다.

인터페이스는 자료 구조와의 상호작용 방법, 즉 어떤 작업을 할 수 있는지, 어떤 입력과 출력을 기대하는지를 명시하는 규약과 같다.

예를 들어, 동적 배열을 생각해보면 추가, 삽입, 제거, 업데이트와 같은 연산이 인터페이스에 포함될 것이다. 이러한 연산은 규칙이 있으며, 요소를 추가할 때는 `.append()`나 `.push()`와 같은 메서드를 사용하여 요소를 전달한다. 대체로 이 연산은 반환값이 없다.

반면, 구현은 자료 구조의 실제 작동 방식을 코드로 나타낸 것이다. 여기서 데이터 저장 방식과 연산 수행 방식의 디테일이 정의된다. 동적 배열의 경우에는 메모리 할당, 크기 추적, 요소 재정렬 등의 작업이 필요하다.

대부분의 자료 구조는 구현이 복잡하고, 복잡한 알고리즘과 데이터 조작을 포함할 수 있다. 그러나 인터페이스와 올바른 사용법만 알면, 이런 세부 사항에 대해서는 크게 걱정할 필요가 없다.

이 글과 다른 강좌에서는 자료 구조의 기본 구현 세부 사항을 다룰 예정이다. 이를 이해하는 것은 중요하지만, 모든 세부 사항을 암기할 필요는 없다. 이 내용은 더 깊은 이해를 위해 포함시킨 것이다.

더 중요한 것은 인터페이스의 이해다. 주요 프로그래밍 언어에서는 대부분의 주요 자료 구조에 대한 기본 구현이 제공된다. 코딩 테스트 시, 기본 제공 자료 구조의 사용법을 알고 있으면 충분하며, 직접 구현할 필요는 없다.

---

이 장에서는 [해싱](https://en.wikipedia.org/wiki/Hash_function)을 사용하여 구현되는 해시 맵과 세트에 대해 설명한다.

해시 함수는 입력을 받아 사용자가 설정한 고정 크기보다 작은 정수로 결정적으로 변환하는 함수다. 입력은 키로 불리며 동일한 입력은 항상 동일한 정수로 변환된다. 다음은 영어 알파벳 문자가 포함된 문자열에 대한 해시 알고리즘의 예이다:

1. 정수 `total`을 초기화한다.
2. 문자열을 순회하며 각 문자를 알파벳 내 해당 위치로 변환한다. 예: `a -> 1`, `c -> 3`, `z -> 26`.
3. 해당 값에 문자열의 현재 위치(인덱스 + 1)를 곱한다. 이를 `total`에 추가한다. 예: 문자열 `"abc"`에서 `b`는 알파벳에서 `2`번째 위치에 있고, 문자열에서도 `2`번째에 있으므로 `2 * 2 = 4`가 `total`에 추가된다.
4. 모든 문자를 처리한 후의 `total`가 변환된 값이다.

이 알고리즘 자체는 좋은 해시 함수는 아니다. 그러나 문자열을 정수로 변환하는 방법의 한 예일 뿐이다. `total`을 고정된 크기로 제한할 필요는 없다. 가정으로 제한을 `x`로 설정하면, 4단계는 다음과 같이 바뀐다:

- 모든 문자를 처리한 후의 값은 `total % x`이다.

`%`는 [모듈로](https://en.wikipedia.org/wiki/Modulo) 연산이며, 최종 변환된 값이 `[0, x - 1]` 범위 내에 있게 한다.

---

## **해시 함수의 의의**

배열은 $$O(1)$$의 상수 시간에 랜덤 액세스가 가능하다는 것을 알고 있다. 임의의 인덱스를 통해 배열의 해당 값을 상수 시간에 접근하고 수정할 수 있다. 배열의 주요 제약은 크기가 고정되어 있고, 인덱스가 정수여야 한다는 것이다. 해시 함수는 모든 입력을 정수로 변환할 수 있기 때문에, 이 제약을 효과적으로 해결할 수 있다. 해시 함수와 배열을 결합하면 **해시 테이블** 또는 **딕셔너리**라고도 하는 **해시 맵**이 생성된다.

배열은 인덱스를 값에 **매핑**하지만, 해시 맵은 **키**를 값에 매핑한다. 해시 맵의 키는 다양할 수 있으며, 일반적으로 키가 **불변**해야 한다는 것이 유일한 제약 조건이다. 값은 어떠한 것도 될 수 있다.

해시 맵은 아마도 모든 알고리즘 면접에서 가장 중요한 개념 중 하나일 것이다. 해시 맵은 매우 효율적이며, 많은 문제에 대한 알고리즘의 시간 복잡성을 $$O(n)$$으로 줄여준다. 대부분의 주요 프로그래밍 언어에는 해시 맵의 [기본 구현](https://en.wikipedia.org/wiki/Hash_table#Implementations)이 있다. 예를 들어, 파이썬에서는 딕셔너리로 알려져 있고, `dic = {}`와 같이 선언할 수 있다. 아마 이 자료 통틀어서 가장 중요한 것은 사용하는 프로그래밍 언어의 해시 맵 인터페이스를 완벽하게 이해하는 것이다.

요약하면, 해시 맵은 키와 값을 쌍으로 저장하는 정렬되지 않은 자료 구조이다. $$O(1)$$의 상수 시간 내에 요소를 추가, 제거하며, 키와 관련된 값을 수정하거나 키의 존재를 확인할 수 있다. 해시 맵의 키와 값을 모두 순회할 수 있지만, 순회의 순서는 정해져 있지 않다.

> 정렬된 자료 구조는 삽입 순서를 유지하는 자료 구조를 의미한다. 반면, 정렬되지 않은 자료 구조는 삽입 순서와 관계 없는 자료 구조를 의미한다.
{: .prompt-general }

---

## **배열과의 비교**

해시 맵은 시간 복잡성 면에서 배열을 앞선다. 해시 맵의 경우 다음 연산은 모두 $$O(1)$$이다:

- 요소 추가 및 값과 연결
- 요소 삭제(해당 요소가 존재할 경우)
- 요소의 존재 여부 확인

해시 맵은 또한 동일한 시간 복잡성을 가진 배열과 많은 유용한 속성을 공유한다:

- 요소의 길이/개수 확인
- 값 업데이트
- 요소 순회

> 해시 맵은 작업하기 더 편하고 깔끔하다. 키가 정수이기 때문에 배열을 사용할 수 있지만, 키의 최대 크기를 모른다면 배열의 크기를 결정하기 어렵다. 해시 맵을 사용하면 키가 크기 제한 내에서 새로운 정수로 변환되기 때문에 그런 걱정을 할 필요가 없다.
{: .prompt-general }

하지만 해시 맵을 사용하는데는 몇 가지 단점도 있다. 작은 입력 크기의 경우 오버헤드 때문에 속도가 느려질 수 있다. 큰 O는 상수를 무시하기 때문에 모든 키가 해시 함수를 거쳐야 하고 **충돌**이 발생할 수 있기 때문에, 실제로 $$O(1)$$의 시간 복잡도가 보통 $$O(10)$$ 정도로 느껴질 수 있다.

해시 테이블은 또한 더 많은 메모리를 사용할 수 있다. 동적 배열은 실제로 저장된 용량을 초과하면 자동으로 크기를 조정하는데, 해시 테이블도 마찬가지다. 문제는 해시 테이블 크기를 조정할 때 모든 키를 다시 해싱해야 하는데, 이 과정 때문에 비용이 많이 든다. 또한 해시 테이블에 저장된 요소 수보다 훨씬 큰 배열을 사용할 수 있어 메모리가 낭비될 수 있다.

> 참고: 시간 복잡도 함수는 사용자가 정의한 변수만을 고려한다. 해시 맵 연산이 $$O(1)$$이라고 할 때, 주로 고려하는 변수는 n이며, 이는 해시 맵의 크기를 의미한다. 그러나 이는 오해의 소지가 있을 수 있다. 예를 들어, 문자열을 해싱하려면 $$O(m)$$의 시간이 필요하며, 여기서 $$m$$은 문자열의 길이이다. 상수 시간 연산은 **맵의 크기에 대해서만 상수**이다.
{: .prompt-general }

---

## **충돌**

두 개의 서로 다른 키가 같은 정수로 변환되는 것을 충돌이라고 한다. 충돌을 처리하지 않으면 이전 키가 덮어쓰여질 수 있어 데이터 손실이 발생한다. 충돌을 처리하는 [방법](https://en.wikipedia.org/wiki/Hash_table#Collision_resolution)은 다양하며, 여기서는 **체이닝**이라는 일반적인 방법을 소개한다.

체이닝을 사용하면 해시 맵의 배열 안에 링크드 리스트를 저장한다. 링크드 리스트의 노드는 키와 값을 모두 저장한다. 충돌이 발생하면 충돌한 키-값 쌍은 링크드 리스트에 추가된다. 특정 키-값 쌍에 접근하려 할 때는 키가 일치할 때까지 링크드 리스트를 순회한다.

해시맵에서 충돌은 처리해야 하는 문제이며, 처리하는 데 시간이 걸린다. 그 결과 해시 맵의 전반적인 속도와 효율성에 영향을 줄 수 있다. 충돌을 최소화하는 방법 중 하나는 해시 테이블의 배열과 [모듈러스](https://stackoverflow.com/questions/1145217/why-should-hash-functions-use-a-prime-number-modulus)가 소수여야 한다는 것이다. 일반적으로 사용되는 대략적인 소수의 크기는 다음과 같다:

- 10,007
- 1,000,003
- 1,000,000,007

---

## **집합 (Set)**

집합은 해시 테이블과 매우 유사한 자료 구조이다. 키를 정수로 해싱하는 것과 동일한 메커니즘을 사용한다. 집합과 해시 테이블의 주요 차이는 집합이 키에 대응하는 값을 저장하지 않는다는 것이다. 집합은 요소의 존재 여부만 확인하기에 적합하다. 집합에서 요소를 추가, 제거, 존재 여부 확인을 모두 $$O(1)$$로 할 수 있다.

집합의 특징 중 하나는 빈도를 추적하지 않는다는 것이다. 만약 집합에 동일한 요소를 100번 추가한다면 첫 번째 요소만 추가되고 나머지는 아무런 영향을 미치지 않는다.

---

## **배열을 키로 사용해도 될까?**

해시 맵의 키가 되기 위해서는 키가 불변이어야 한다. 그런데 배열은 가변성을 가지므로 어떻게 정렬된 요소 컬렉션을 키로 사용할 수 있을까? 사용하는 프로그래밍 언어에 따라 배열을 고유한 불변 키로 변환하는 방법이 다르다. Python에서는 튜플이 불변성을 가지기 때문에 `tuple(arr)`을 사용할 수 있다. 또 다른 방법은 배열의 요소를 특정 구분자로 연결하여 문자열로 변환하는 것이다. 예를 들면 `[1, 51, 163] --> "1,51,163"`와 같이 변환한다. `C++`와 같은 언어는 기본적으로 가변성을 가진 키를 지원하기도 한다.

---

## **인터페이스 가이드**

다음은 C++에서 사용되는 해시 맵 인터페이스에 대한 설명이다:

```cpp
// 선언: C++는 여러 구현을 지원하지만, 여기서는 std::unordered_map을 사용한다.
// 키와 값의 데이터 타입을 지정한다.
unordered_map<int, int> hashMap;

// 키와 값의 쌍으로 초기화하려면 다음 문법을 사용한다:
unordered_map<int, int> hashMap = {% raw %}{{1, 2}, {5, 3}, {7, 2}}{% endraw %};

// 키의 존재 여부를 확인: 다음 문법을 사용한다.
hashMap.find(1) != hashMap.end(); // true
hashMap.find(9) != hashMap.end(); // false

// 키를 사용하여 값을 액세스: 배열과 유사하게 대괄호를 사용한다.
hashMap[5]; // 3

// 키 추가 또는 업데이트: 배열과 유사하게 대괄호를 사용한다.
// 키가 이미 존재하면 값이 업데이트된다.
hashMap[5] = 6;

// 키가 아직 존재하지 않으면 키-값 쌍이 삽입된다.
hashMap[9] = 15;

// 키 삭제: .erase() 메서드를 사용한다.
hashMap.erase(9);

// 크기 얻기
hashMap.size(); // 3

// 키와 값의 쌍을 반복하여 순회: 다음 코드를 사용한다.
// .first는 키를 가져오고 .second는 값을 가져온다.
for (auto const& pair: hashMap) {
    cout << pair.first << " " << pair.second << endl;
}
```

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/705/hashing/4510/)
