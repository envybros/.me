---
title: "Rust 30분 컷하기"
categories: [Rust 연구소]
tags: [Rust]
date: 2023-07-14 00:10
---

여기서는 내용 하나에 집중하기 보다는, 전체적인 Rust의 스니펫을 훑어볼 것이다.

---

## **변수**

`let`으로 변수 바인딩을 할 수 있다.

```rust
let x; // "x" 선언
x = 42; // "x"에 42를 할당
```

아래와 같이 한 줄로 표현할 수도 있다.

```rust
let x = 42;
```

타입 어노테이션 `:`을 사용하여 변수의 타입을 명시적으로 지정할 수 있다.

```rust
let x: i32; // `i32`는 부호 있는 32-bit 정수이다.
x = 42;

// 마찬가지 i8, i16, i32, i64, i128
//    이는 u8, u16, u32, u64, u128 <- 부호 없는 정수
```

한 줄로 작성할 수도 있다.

```rust
let x: i32 = 42;
```

변수명을 먼저 선언하고, 초기화를 나중에 한다면, 해당 변수가 초기화되기 전까지 컴파일러는 해당 변수를 사용할 수 없게 된다.

```rust
let x;
foobar(x); // error: 초기화되지 않았을 가능성이 있는 변수를 빌려온다: `x`
x = 42;
```

물론 이렇게 하는건 문제 없다.

```rust
let x;
x = 42;
foobar(x); // 여기서 `x`의 타입을 유추할 수 있게 된다.
```

밑줄 `_`은 특별한 이름, 즉 "이름 생략"을 의미한다. 기본적으로 무언가를 버린다는 뜻이다:


```rust
// 42는 상수이기 때문에 이것은 *아무것도* 하지 않는다.
let _ = 42;

// `get_thing`을 호출하지만 그 결과를 버린다.
let _ = get_thing();
```

밑줄로 시작하는 이름은 평범한 이름이며, 그저 컴파일러가 사용하지 않는 이름에 대해 경고하지 않을 뿐이다:

```rust
// 나중에 `_x`를 사용할 수도 있지만, 
// 지금은 코드가 작업 중이므로 지금은 컴파일러 경고를 없애고 싶었다.
let _x = 42;
```

같은 변수명을 가진 별도의 바인딩을 도입할 수 있다. 변수 바인딩을 *섀도잉*할 수 있다:

```rust
let x = 13;
let x = x + 3;
// 그 줄 뒤에 `x`를 사용하면 두 번째 `x`만 참조한다,
// 첫 번째 `x`는 더 이상 존재하지 않게 된다.
```

Rust에는 Tuple이 있으며, 이는 "다양한 타입의 값의 고정 길이 컬렉션"이라고 생각할 수 있다.

```rust
let pair = ('a', 17);
pair.0; // -> 'a'
pair.1; // -> 17
```

아래와 같이 `pair` 타입에 어노테이션(`:`)을 넣고 싶다면, 이렇게 작성할 수도 있다.

```rust
let pair: (char, i32) = ('a', 17);
```

할당 작업을 수행할 때 Tuple이 *파괴*될 수 있다. 이는 개별 필드로 세분화된다는 의미이다.

```rust
let (some_char, some_int) = ('a', 17);
// 이제, `some_char`는 'a'이고, `some_int`는 17이다.
```

이것은 함수가 Tuple을 반환할 때 특히 유용하다.

```rust
let (left, right) = slice.split_at(middle);
```

물론 Tuple을 파괴할 때 `_`를 사용하여 Tuple의 일부를 버릴 수도 있다:

```rust
let (_, right) = slice.split_at(middle);
```

세미콜론은 문장의 끝을 표시한다:

```rust
let x = 3;
let y = 5;
let z = y + x;
```

이는 문(Statement)이 여러 줄에 걸쳐 있을 수 있음을 의미한다:

```rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
```

(위 내용이 어떤 의미인지는... 나중에 자세히 설명할 예정이다).

---

## **함수**

`fn`으로 함수를 선언할 수 있다.

다음은 `void` 함수이다:

```rust
fn greet() {
    println!("Hi there!");
}
```

다음은 32-bit 부호 있는 정수를 반환하는 함수입니다. 화살표는 반환 유형을 나타냅니다:

```rust
fn fair_dice_roll() -> i32 {
    4
}
```

한 쌍의 괄호는 자체 범위가 있는 블록을 선언한다:

```rust
// "in"을 출력하고, "out"을 출력한다.
fn main() {
    let x = "out";
    {
        // 이건 위 `x`와 다르다.
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
```

블록 또한 표현식이므로 값을 평가한다.

```rust
// 이것은:
let x = 42;

// 아래와 같다.:
let x = { 42 };
```

블록 안에는 여러 개의 문이 있을 수 있다:

```rust
let x = {
    let y = 1; // 첫번째 문
    let z = 2; // 두번째 문
    y + z // *꼬리* - 이곳이 전체 블록을 평가할 마지막 부분이다.
};
```

"함수 내부의 마지막 문에 세미콜론을 생략하는 것"은 값을 반환하는 것과 동일하다:

```rust
fn fair_dice_roll() -> i32 {
    return 4;
}

fn fair_dice_roll() -> i32 {
    4
}
```

---

## **조건문**

`if` 조건문도 표현식(expressions)이다:

```rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```

`match` 또한 표현식이다:

```rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}
```

점 (`.`)은 일반적으로 값의 필드에 접근하는 데 사용된다.

```rust
let a = (10, 20);
a.0; // -> 10

let amos = get_some_struct();
amos.nickname; // -> "pulp-pixel"
```

또는 값에 대한 메서드를 호출할 수 있다:

```rust
let nick = "pulp-pixel";
nick.len(); // 10
```

---

## **Crate**

이중 콜론인 `::`는 위와 비슷하지만, 이는 네임스페이스에서 작동한다.

이 예에서 `std`는 *crate* (라이브러리), `cmp`는 *module* (소스 파일), `min`은 *function* 이다:

```rust
let least = std::cmp::min(3, 8); // -> 3
```

`use` 지시문을 사용하여 다른 네임스페이스로부터 이름들을 "범위 내로" 가져올 수 있다.

```rust
use std::cmp::min;

let least = min(7, 1); // -> 1
```

`use` 지시어 내에서의 중괄호는 "globs"를 의미한다. `min`과 `max`를 모두 가져오려면 이 중 하나를 사용하면 된다:

```rust
// 작동 한다:
use std::cmp::min;
use std::cmp::max;

// 마찬가지로 작동한다:
use std::cmp::{min, max};

// 여까지 작동한다!! (globe)
use std::{cmp::min, cmp::max};
```

와일드카드(`*`)를 사용하면 네임스페이스에서의 모든 심볼을 가져올 수 있다:

```rust
// 이것은 범위의 `min`과 `max`를 가져오고, 또 나머지 것들까지 가져온다.
use std::cmp::*;
```

타입들 또한 네임스페이스이며 메서드를 일반 함수로 호출할 수 있다:

```rust
let x = "amos".len(); // -> 4
let x = str::len("amos"); // 이 또한 4
```

---

## **문자열**



