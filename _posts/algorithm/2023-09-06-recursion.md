---
title: "재귀(Recursion) 소개"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-06 01:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

재귀(Recursion)는 문제를 해결하는 방식 중 하나로, 함수가 자기 자신을 다시 호출하는 형태로 작동한다.

재귀의 반대 개념은 반복 알고리즘이다. 모든 반복 알고리즘은 재귀로도 표현할 수 있다: [참고 자료](https://en.wikipedia.org/wiki/Computability_theory). 반복 알고리즘은 for 루프나 while 루프로 동작을 반복하며, 재귀 알고리즘은 함수 호출로 같은 로직을 반복한다.

예를 들어 1부터 10까지의 숫자를 출력하는 경우를 생각해보자. 아래는 그에 대한 반복 알고리즘의 의사 코드(pseudocode)이다:

```cpp
for (int i = 1; i <= 10; i++) {
    print(i)
}
```

다음은 재귀를 사용한 의사 코드 예시이다:

```cpp
function fn(i):
    print(i)
    fn(i + 1)
    return

fn(1)
```

`fn`을 호출할 때마다 `i`(1부터 시작)를 출력하고 다시 `fn`을 호출한다. 이때 `i`에 1을 더한 값을 인자로 전달한다.

> 첫 번째 함수 호출에서 `1`을 출력 후 `fn(2)`를 호출한다. `fn(2)`에서 `2`를 출력 후 `fn(3)`을 호출하는 방식으로 계속된다.
{: .prompt-general }

그러나 이 코드에는 문제가 있다. 함수 호출이 종료되지 않는다. 코드를 실행하면 자연수가 계속 출력된다. 왜냐하면 `return` 문 앞에 `fn(i + 1)`이 있기 때문에, 이 함수는 계속 호출된다.

재귀 호출을 중단하기 위해서는 **기저 조건(Base Case)**이 필요하다. 기저 조건은 재귀 함수 호출 시 종료할 수 있는 조건을 정의한다.

```cpp
function fn(i):
    if i > 10:
        return

    print(i)
    fn(i + 1)
    return

fn(1)
```

> `fn(10)`을 호출하면 `10`을 출력한 후 `fn(11)`을 호출한다. `fn(11)`에서는 기저 조건을 만족시켜 반환하고, 다시 `fn(10)`으로 돌아간 후, `return` 문을 실행한다. 그 다음 `fn(9)`로 돌아가며, 최종적으로 `fn(1)`로 돌아간다. 이렇게 재귀 알고리즘이 종료될 때까지 이 과정이 반복된다.
{: .prompt-general }

재귀의 복잡한 부분은 명령어의 실행 순서를 이해하는 것이다. 반복 알고리즘은 간단하게 위에서부터 아래로 코드를 실행하면 되지만, 재귀는 서로 연결된 함수 호출 때문에 이해하기가 조금 더 복잡할 것이다. 이해를 돕기 위해 다음 코드를 살펴보자:

```cpp
function fn(i):
1.  if i > 3:
2.    return

3.  print(i)
4.  fn(i + 1)
5.  print(f"End of call where i = {i}")
6.  return

fn(1)
```

이 코드의 출력 결과는 다음과 같다:

```cpp
// 1
// 2
// 3
// End of call where i = 3
// End of call where i = 2
// End of call where i = 1
```

코드의 실행 순서를 살펴보면, `fn(1)`은 `1`을 출력하고, `fn(2)`를 호출한다. 그리고 `fn(2)`는 `2`를 출력하고, `fn(3)`을 호출한다. 그리고 `fn(3)`은 `3`을 출력하고 `fn(4)`를 호출한다. **여기부터가 중요한 부분이다**: `fn(4)`에서는 기저 조건에 따라 함수가 반환되고, 이전 호출인 `fn(3)`으로 돌아와서 **5번째 줄**을 실행한다. 이렇게 함수가 하나씩 반환되면서 출력문이 실행된다.

> 모든 함수 호출은 그 호출이 종료될 때까지 유지된다. 다른 함수를 호출하더라도 원래의 함수는 새 함수가 반환될 때까지 대기한다. 호출 순서는 기억되며, 함수 내의 명령어는 순차적으로 실행된다.
>
> 또한 각 함수 호출마다 고유한 지역 변수가 있다. 위의 예에서, `fn(3)`을 호출할 때 동시에 3개의 `i` 변수가 독립적으로 존재한다: 첫 번째 호출에서 `i = 1`, 두 번째 호출에서 `i = 2`, 그리고 세 번째 호출에서 `i = 3`. 만약 `fn(3)` 내에서 `i` 값을 변경하더라도 다른 호출에서의 `i` 값은 영향받지 않는다.
{: .prompt-general }

---

## 문제 분석하기

위의 출력 예제는 실질적으로 큰 의미가 없다. 단순히 숫자 출력을 목표로 한다면 for 루프를 사용하는 편이 간편하다. 재귀의 장점은 문제를 작은 "하위 문제"로 나누고, 그 해결책들을 조합하여 주어진 문제를 해결할 때 가장 두드러진다.

[피보나치수](https://en.wikipedia.org/wiki/Fibonacci_number)를 예로 들어보자. 피보나치 수열은 `0, 1`로 시작하고, 다음 수는 바로 앞의 두 수를 더한 것이다. 초기 피보나치 수열은 `0, 1, 1, 2, 3, 5, 8`과 같다. 이를 수식으로 나타내면:

$$F{n} = F_{n - 1} + F_{n - 2}$$

이것을 **점화식 (recurrence relation)**이라고 하며, 연속을 갖는 수들 간의 관계를 나타낸다.

아래는 $$n^{th}$$ 피보나치수를 반환하는 함수 `F(n)`의 의사 코드다. 재귀에서 중요한 것은 기저 조건을 잘 설정하는 것이다. 여기서 기저 조건은 `F(0) = 0` 및 `F(1) = 1`로 명확하게 주어진다.

```cpp
function F(n):
    if n <= 1:
        return n

    oneBack = F(n - 1)
    twoBack = F(n - 2)
    return oneBack + twoBack
```

`F(3)`을 찾고 싶다고 가정해보자. `F(3)`을 호출하면 다음과 같은 흐름이 표시되며, 각 들여쓰기 수준은 함수 호출의 범위를 나타낸다:

```cpp
oneBack = F(2)
    oneBack = F(1)
        // 결과: F(1) = 1
    twoBack = F(0)
        // 결과: F(0) = 0
    // 결과: F(2) = oneBack + twoBack = 1
twoBack = F(1)
    // 결과: F(1) = 1
// 결과: F(3) = oneBack + twoBack = 2
```

여기서 중요한 것은 `F(3)`을 풀기 위해 `F(2)`와 `F(1)`이라는 작은 문제로 나눴다는 것이다. 점화식과 기저 조건을 활용해 하위 문제들을 해결하고, 그 해결책들을 결합하여 주어진 문제를 해결한다.

재귀의 핵심은 **주어진 입력에 따라 해결하려는 문제의 답을 반환하는 것**이다. 여기서 주어진 입력에 따른 문제는 "n번째 피보나치 수는 무엇인가?"이다. 이를 바탕으로 기저 조건과 점화식을 정하면, 함수를 쉽게 설계하고 구현할 수 있다.

이런 접근 방식으로, 원하는 피보나치 수를 쉽게 구할 수 있다. 100번째 피보나치 수를 알고 싶다면, 99번째와 98번째 피보나치 수를 합친 것이라는 걸 알 수 있다. 그리고 `F(100)` 함수를 호출하면, 내부에서는 `F(99)`와 `F(98)` 함수 호출을 통해 원하는 값을 얻게 된다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4655/)
