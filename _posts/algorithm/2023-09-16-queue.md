---
title: "큐 (Queue)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-16 02:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

스택이 LIFO 패턴을 따르는 반면, 큐는 FIFO (선입선출)를 따릅니다. 스택에서는 요소가 같은 쪽에서 추가되고 제거된다. 큐에서는 요소가 반대쪽에서 추가되고 제거된다. 스택과 마찬가지로 큐를 구현하는 방법에는 여러 가지가 있지만, 큐를 정의하는 중요한 것은 반대쪽에서 추가 및 제거라는 추상적인 인터페이스이다.

실제 세계에서 대기열의 예로는 패스트푸드점의 줄을 들 수 있다. 사람들은 주문을 마치면(앞쪽에서) 줄을 떠나고, 사람들은 뒤쪽(반대쪽 끝)에서 줄에 들어갑니다. 가장 먼저 줄에 들어온 사람이 가장 먼저 줄을 떠나는 사람(FIFO)이 된다. 실제 소프트웨어 세계에서 대기열의 예로는 여러 사람이 동시에 프린터를 사용하려는 경우와 같이 선착순으로 작업을 처리하는 모든 시스템을 들 수 있다.

좋은 성능을 유지하려면 큐를 스택보다 구현하기가 더 까다롭다. 스택과 마찬가지로 동적 배열을 사용할 수 있지만 배열 앞쪽의 연산(추가 또는 제거)은 O (n)이며, 여기서 n은 배열의 크기이다. 큐에 추가하는 것을 enqueue라고 하고 삭제하는 것을 dequeue라고 한다. 이러한 연산을 O (1) 로 만들려면 좀 더 정교한 구현이 필요하다.

효율적인 큐를 구현하는 한 가지 방법은 이중 링크 목록을 사용하는 것이다. 이중 링크 리스트를 사용하면 노드에 대한 포인터가 있으면 해당 위치에서 O (1)로 추가하거나 삭제할 수 있다는 점을 기억하자. 헤드와 테일(보통 센티널 노드가 있는 양쪽 끝)에 대한 포인터를 유지하는 이중 링크 리스트는 효율적인 큐를 구현할 수 있다.

> 양쪽 끝 큐의 줄임말로 "덱"이라고 발음되는 덱이라는 데이터 구조도 있다. 큐에서는 양쪽 끝에서 요소를 추가하거나 삭제할 수 있다. 일반 큐는 한쪽 끝에서 추가하고 다른 쪽 끝에서 삭제하는 것을 지정한다.
{: .prompt-general }

알고리즘 문제의 경우, 큐는 스택보다 덜 일반적이며 일반적으로 문제가 더 어렵다. 큐의 가장 일반적인 용도는 향후 장에서 배우게 될 BFS(폭 우선 검색)라는 알고리즘을 구현하는 것이다. 스택과 달리 큐가 주요 초점인 문제는 많지 않다. 몇 가지 예를 살펴보겠지만 큐는 주로 BFS를 구현하는 데 사용된다는 점을 명심하자.

---

## **인터페이스 가이드**

다음은 C++로 된 대기열 인터페이스에 대한 간략한 설명이다:

```cpp
// Declaration: C++ supports multiple implementations, but we will be using
// std::queue. Specify the data type
queue<int> queue;

// Enqueueing/adding elements:
queue.push(1);
queue.push(2);
queue.push(3);

// Dequeing/removing elements:
queue.pop();

// Check if empty
queue.empty(); // false

// Check element at front of queue (next element to be removed)
queue.front(); // 2

// Get size
queue.size(); // 2
```

---

> **예제**: [최근 통화 횟수](https://leetcode.com/problems/number-of-recent-calls/)
>
> RecentCounter 클래스를 구현한다. 이 클래스는 시간 t에 호출을 기록한 다음 [t - 3000, t] 범위에서 발생한 호출 수를 나타내는 정수를 반환하는 ping(int t)을 지원해야 한다. ping에 대한 호출은 t가 증가한다.
{: .prompt-general }

정수가 증가하는 스트림이 있고, 스트림에 정수를 추가할 때마다 스트림에 3000 이내의 숫자가 몇 개 있는지 찾아야 한다. 무차별 대입 방식은 모든 정수를 배열에 넣고 매번 배열을 반복하여 3000 이내에 정수가 몇 개 있는지 계산하는 것이다. 이 방법은 매우 비효율적이다. 값 x가 있다고 가정해 보겠다. t가 x + 3000을 넘어가면, 앞으로 ping을 호출할 때마다 x가 포함되지 않는다는 것을 이미 알고 있음에도 불구하고 x에 대해 반복해야 한다. x가 오래되면 바로 제거해야 한다.

동적 배열에서 이 작업을 수행하려면 앞쪽에서 t - 3000보다 작은 값을 제거하면 된다. 하지만 배열의 앞쪽에서 제거할 때 O (n)이므로 여전히 비효율적이다. 여기서 n은 배열의 크기이다. 대신 효율적인 큐를 사용하면 이러한 제거는 O (1) 이 됩니다! 큐를 사용하여 숫자를 저장하고 각 호출마다 오래된 요소를 모두 제거한 후 개수를 반환해 보자.

```cpp
class RecentCounter {
public:
    queue<int> queue;
    
    RecentCounter() {}
    
    int ping(int t) {
        while (!queue.empty() && queue.front() < t - 3000) {
            queue.pop();
        }
        
        queue.push(t);
        return queue.size();
    }
};

/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter* obj = new RecentCounter();
 * int param_1 = obj->ping(t);
 */
```

파이썬에서는 [collections.deque](https://docs.python.org/3/library/collections.html#collections.deque)를 사용해 큐를 구현한다. 이 데이터 구조는 O (1)의 앞쪽에서 큐 작업을 수행할 수 있게 해줍니다.

> 큐가 그 자체로 빛을 발하는 문제는 많지 않기 때문에 이 글은 다소 부족하다. 하지만 트리 및 그래프 챕터에서 매우 강력한 알고리즘인 BFS를 구현하는 데 큐가 어떻게 사용되는지 확인할 수 있으니 걱정하지 않아도 좋다.
{: .prompt-general }

다음 패턴인 단조로운 패턴은 스택과 큐 모두에 적용된다. 대기열 문제를 몇 가지 더 살펴볼 것이다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/706/stacks-and-queues/4516/)
