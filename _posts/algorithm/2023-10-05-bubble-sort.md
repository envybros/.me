---
title: "버블 정렬 (Bubble Sort)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-05 00:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---
## 개요

> ![Bubble](BubbleSort_Avg_case.gif)  
> 분류: **정렬 알고리즘**  
> 자료 구조: **배열**  
> 최악 시간복잡도: 비교: $$O(n^2)$$, 교환: $$O(n^2)$$  
> 최선 시간복잡도: 비교: $$O(n)$$, 교환: $$O(1)$$  
> 평균 시간복잡도: 비교: $$O(n^2)$$, 교환: $$O(n^2)$$  
> 공간복잡도: 보조: $$O(1)$$  
{: .prompt-general }

**버블 정렬**은 시간 복잡도가 $$O(n^2)$$로 상당히 느리지만, 구현이 쉽기 때문에 자주 사용되는 알고리즘 중 하나이다. 버블 정렬을 양방향으로 번갈아 수행하면 칵테일 정렬이 된다.

---

## 알고리즘

1. 배열의 두 요소(a, b)를 선택한다.
2. 만약 해당 요소들이 이미 정렬되었다면 패스하고, 아니라면 두 요소를 Swap한다.
3. 이 과정을 배열의 처음부터 끝까지 반복한다.
4. 배열에 아무런 변화가 없을 때까지 이를 반복 수행한다.

여기서 버블 정렬의 특징 중 하나로, 버블 정렬 과정을 한바퀴 돌리고 나면 가장 큰 숫자가 가장 마지막 자리로 이동하게 된다. 

즉, 첫번째 과정에서는 (n-1)번째 요소까지 비교가 필요했다면, 두번째 과정에서는 (n-2)까지만 비교하면 된다.

---

## 구현

버블 정렬에 대한 cpp 구현은 다음과 같다.

```cpp
void swap(int &a, int &b) {
    int tmp = a;
    a = b;
    b = tmp;
}

void bubbleSort(int arr[], int n) {
    // n-1: 마지막 요소는 검사할 필요가 없다.
    for (int i = 0; i < n-1; i++) {
        // n-i-1: 매 반복마다 가장 큰 요소가 마지막으로 이동하고,
        // 정렬되지 않은 부분만을 대상으로 진행할 수 있도록 한다.
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

```

---

## 시간 복잡도

각 비교에 소요되는 시간을 상수 $$C$$라고 생각해보자. 

그렇다면 버블 정렬에 소요되는 총 시간은 $$C*(N-1 + N-2 + ... + 2 + 1)$$이다.

즉, 시간 복잡도는 $$O(n^2)$$ 이다.

---

## 공간 복잡도

버블 정렬에서는 추가적인 공간을 사용하지 않기 때문에 공간 복잡도는 $$O(1)$$이다.

---

## 장점

- 데이터 세트의 크기가 작은 경우 효율적이다.
- 구현이 매우 간단하다.
- 추가 메모리를 요소하지 않으므로, 메모리 효율적이다.
- 안정적인 정렬을 제공한다. (실패률이 거의 없다.)

---

## 단점

- 시간 복잡도가 $$O(n^2)$$로 큰 편이다.
- 데이터 세트의 크기가 큰 경우, 시간이 기하급수적으로 증가하기 때문에 효율성이 떨어진다.

---

참고 자료:

- [codepumpkin](https://codepumpkin.com/bubble-sort/)
- [wiki](https://ko.wikipedia.org/wiki/%EB%B2%84%EB%B8%94_%EC%A0%95%EB%A0%AC)
