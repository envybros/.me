---
title: "DP를 위한 프레임워크"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-05 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

DP 문제를 해결하기 위한 프레임워크를 소개한다. 이 프레임워크는 모든 DP 문제에 적용될 수 있고 알고리즘을 체계적으로 개발하는 방법을 제공하기 때문에 우리가 기억해두기 좋은 도구이다.

> 이 글에서는 [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs)를 예로 들어 설명할 것이다. 우선, 상향식 해결책부터 시작할 것이다.
>
> 정수 배열 `cost`가 주어지는데, 여기서 `cost[i]`는 계단의 $$i$$번째 단계에서의 비용이다. 비용을 지불하면 한 번에 한 단계 또는 두 단계를 오를 수 있다. 인덱스 0의 단계나 인덱스 1의 단계에서 시작할 수 있다. 최상층(배열의 밖, `cost`의 마지막 인덱스가 아님)에 도달하기 위한 최소 비용을 반환해야 한다.
>
> 문제 링크를 새 탭에서 열어 쉽게 따라갈 수 있도록 하는 것이 좋다.
{: .prompt-general }

---

## **프레임워크**

어떤한 DP 알고리즘을 만들더라도, 거기에는 3가지 주요 구성 요소가 있다.

1. **주어진 상태에 대한 문제의 답을 계산/포함할 함수 또는 자료 구조**

우리는 상향식 해결 방법부터 시작하므로 여기서는 함수에 대해 이야기할 것이다. 이것은 두 부분으로 나뉜다. 첫째, 함수가 반환하는 것을 결정해야 한다. 둘째, 함수가 가져야 할 인수(state 변수)를 결정해야 한다.

문제는 계단을 오르는 최소 비용을 요구한다. 그래서 주어진 `state`에 대한 계단 오르기의 최소 비용을 반환하는 함수 `dp(state)`를 정의하자.

어떤 상태 변수가 필요한가? 관련된 유일한 상태 변수는 입력을 따라가는 인덱스일 것이다, 이를 `i`라고 하자.

> 상태 변수에 대해 생각하는 좋은 방법은 문제가 현실 세계의 시나리오라고 상상하는 것이다. 시나리오를 100% 서술하기 위해 어떤 정보가 필요한가? 우리는 어떤 단계에 있는지 알아야 한다 - 여기서 `i`가 필요하다. 양말의 색깔은 어떤가? 녹색 양말을 신고 5단계에 서있는 것은 기술적으로 빨간 양말을 신고 5단계에 서있는 것과 다른 상태지만, 단계의 비용이나 관련 있는 다른 것은 변하지 않는다.
{: .prompt-general }

그러므로, $$i$$번째 단계까지 계단을 오르는 최소 비용을 반환하는 함수 `dp(i)`를 가지자.

{:start="2"}
2. **상태 간의 전환을 위한 순환 관계**

순환 관계란 상태를 계산하는데 사용되는 방정식이다. 피보나치에서의 순환 관계는 $$F_n$$ = $$F_{n-1}$$ + $$F_{n-2}$$였다.

이 문제에서, 우리가 $$100$$번째 단계로 오르는 최소 비용을 알아내고 싶다고 가정해보자. 문제는 각 단계에서 한 단계나 두 단계를 오를 수 있다고 명시한다. 즉, $$100$$번째 단계에 도달하려면 $$99$$번째 또는 $$98$$번째 단계에서 와야 한다. 따라서, $$100$$번째 단계로 오르는 최소 비용은 $$99$$번째 단계까지의 최소 비용 + $$99$$번째 단계의 비용이거나, $$98$$번째 단계까지의 최소 비용 + $$98$$번째 단계의 비용 중 하나다.

`dp(100) = min(dp(99) + cost[99], dp(98) + cost[98])`

> 이전 단계에서 `dp`를 정의한 방식 때문에, `dp(99)`는 $$99$$번째 단계까지 가는 최소 비용을, `dp(98)`는 $$98$$번째 단계까지 가는 최소 비용을 준다.
{: .prompt-general }

또는 더 일반적으로:

`dp(i) = min(dp(i - 1) + cost[i - 1], dp(i - 2) + cost[i - 2])`

이것이 이 문제의 순환 관계다. 일반적으로 순환 관계를 찾는 것이 DP 알고리즘을 구축하는 가장 어려운 부분이다. 이 경우는 비교적 간단하지만, 나중에 순환 관계가 훨씬 복잡할 수 있다는 것을 알게 될 것이다.

{:start="3"}
3. **종료 조건**

순환 관계만으로는 쓸모가 없다. 우리는 여전히 `dp(100)`을 알 수 없다 왜냐하면 `dp(99)`나 `dp(98)`을 모르기 때문이다. 만약 우리가 그것들을 찾으려고 시도한다면, 우리는 같은 문제를 가질 것이다 - 우리는 어떻게 `dp(97)` 또는 `dp(96)`을 모르면 `dp(98)`를 알 수 있을까? 그 자체로, 순환 관계는 `dp(-infinity)`까지 영원히 계속될 것이다.

우리 함수가 결국 실제 값을 반환하도록 하기 위해 종료 조건이 필요하다. 문제는 우리가 `0`단계나 `1`단계에서 시작할 수 있다고 말한다. 따라서, 종료 조건은 다음과 같다:

`dp(0) = dp(1) = 0`

이러한 종료 조건으로, 우리는 `dp(2)`를 찾을 수 있다. `dp(2)`로, 우리는 `dp(3)`을 찾을 수 있고, 이렇게 계속해 `dp(98)`와 `dp(99)`를 가질 수 있고, 마침내 `dp(100)`을 찾을 수 있다.

> 종료 조건을 파악하는 것은 보통 꽤 쉽고, 조금의 논리적 사고만 필요하다. 모든 질문을 주의 깊게 읽는 것이 중요하다.
{: .prompt-general }

---

## **구현**

이제 프레임워크의 세 부분을 합쳐 알고리즘을 만들어보자. 함수를 메모이제이션해서 시간 복잡도를 $$O(2^n)$$에서 $$O(n)$$으로 향상시키는 것을 잊지 말자. 여기서 $$n$$은 입력 배열의 길이다.

```cpp
class Solution {
public:
    vector<int> cost;
    vector<int> memo;
    
    int minCostClimbingStairs(vector<int>& cost) {
        this->cost = cost;
        memo = vector(cost.size() + 1, -1);
        return dp(cost.size());
    }
    
    int dp(int i) {
        if (i <= 1) {
            return 0;
        }
        
        if (memo[i] != -1) {
            return memo[i];
        }
        
        memo[i] = min(dp(i - 1) + cost[i - 1], dp(i - 2) + cost[i - 2]);
        return memo[i];
    }
};
```

---

## **상향식 해결책을 하향식으로 변환하기**

이전 글에서 언급했듯이, 하향식 대신 상향식을 사용하는 장점이 있다. 때때로 면접관은 두 접근 방식을 모두 요구할 수 있다. 다음은 하향식 재귀 해결책을 상향식 반복적인 것으로 변환하는 일반적인 방법이다.

1. 하향식 접근 방식을 구현하면서 시작하자.
2. 상태 변수에 따라 크기가 조정된 배열 dp를 초기화한다. 예를 들어, 문제의 입력이 배열 $$nums$$와 최대 허용 행동 수를 나타내는 정수 k였다고 하자. 그러면 배열 dp는 $$nums.length$$의 길이를 가진 차원 하나와 k의 길이를 가진 다른 차원으로 2D가 될 것이다. 하향식 접근 방식에서는 함수 `dp`가 있었다. 이 둘이 동등하길 원한다. 예를 들어, `dp(4, 6)`의 값은 이제 `dp[4][6]`에서 찾을 수 있다.
3. 하향식 함수에서 사용하는 것과 동일한 종료 조건을 설정한다. 방금 살펴본 예에서, 우리는 `dp(0) = dp(1) = 0`을 가졌다. `dp` 배열 값을 `0`으로 초기화하여 이 종료 조건을 암시적으로 설정할 수 있다. 곧 보게 될 것처럼, 다른 문제들은 더 복잡한 종료 조건을 가질 것이다.
4. 상태 변수를 순회하는 for 루프를 작성한다. 여러 상태 변수가 있으면 중첩 for 루프가 필요할 것이다. 이 루프는 **종료 조건에서 시작하여 정답 상태에서 끝나야 한다**.
5. 이제 가장 안쪽 루프의 각 반복은 주어진 상태를 나타내며, 상향식에서 동일한 상태로의 함수 호출과 동일하다. 함수에서 로직을 복사하여 for 루프에 붙여넣고 함수 호출을 배열 접근으로 변경한다. 모든 $$dp(...)$$는 $$dp[...]$$로 바뀐다.
6. 다 됐다! 이제 $$dp$$는 가능한 모든 상태에 대한 원래 문제의 답으로 채워진 배열이다. $$dp(...)$$를 $$return dp[...]$$로 변경하여 원래 문제의 정답을 반환한다.

다음은 위의 동일한 알고리즘의 상향식 구현이다.

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        // Step 2
        vector<int> dp(n + 1);

        // Step 3: 종료 조건은 0이기 때문에 암시적으로 정의된다

        // Step 4
        for (int i = 2; i <= n; i++) {
            // Step 5
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        
        // Step 6
        return dp[n];
    }
};
```

다음 글에서 몇 가지 예제 DP 문제로 들어가 보자.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/712/dynamic-programming/4540/)

<!--

{: .prompt-general }

-->