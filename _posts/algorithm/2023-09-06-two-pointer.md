---
title: "투 포인터 (Two pointer)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-06 00:20
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

투 포인터는 배열과 문자열 문제를 푸는 데 사용되는 매우 일반적인 기법이다. 여기에는 반복자(Iterable)를 따라 이동하는 두 개의 정수 변수가 포함된다. 이 글에서는 배열과 문자열에 초점을 맞추고 있다. 즉, 배열이나 문자열의 인덱스를 나타내는 두 개의 정수가 있는데, 대체로 `i`와 `j` 또는 `left`와 `right` 같은 이름을 갖는다.

투 포인터를 구현하는 방법에는 여러 가지가 있다. 먼저 다음 방법을 살펴보도록 하자:

> 입력의 가장자리에서 포인터를 시작한다. 포인터가 서로 만날 때까지 서로를 향해 이동한다.
{: .prompt-general }

이제 이 아이디어를 명령어로 변환한다:

1. 한 포인터는 첫 번째 인덱스 `0`에서 시작하고, 다른 포인터는 마지막 인덱스 `input.length - 1`에서 시작한다.
2. 포인터가 서로 같아질 때까지 while 루프를 사용한다.
3. 루프의 각 반복에서 포인터를 서로를 향해 이동시킨다. 즉, 첫 번째 인덱스에서 시작한 포인터를 증가시키거나 마지막 인덱스에서 시작한 포인터를 감소시키거나 아니면 둘 다 수행한다. 어떤 포인터를 이동할지 결정하는 것은 해결하려는 문제에 따라 달라진다.

다음은 해당 개념을 설명하는 의사 코드이다:

```cpp
function fn(arr):
    left = 0
    right = arr.length - 1

    while left < right:
        Do some logic here depending on the problem
        Do some more logic here to decide on one of the following:
            1. left++
            2. right--
            3. Both left++ and right--
```

이 기법의 강점은 포인터가 서로 $$n$$만큼 떨어져서 시작하고 모든 반복에서 적어도 한 단계 더 가까이 이동하기 때문에 while 루프에 대해 $$O(n)$$ 이상의 반복이 발생하지 않는다는 것이다. 따라서 각 반복 내부의 작업을 $$O(1)$$로 유지할 수 있다면, 이 기법을 사용했을 때 선형 런타임이 발생하게 된다. 이는 가능한 최상의 런타임이 될 것이다. 몇 가지 예시를 살펴보자.

---

> 예제 1: 문자열 `s`가 주어졌을 때, 이것이 팔린드롬(palindrome)이면 `true`를 반환하고, 아니면 `false`를 반환한다.
>
> 여기서 팔린드롬이란, "문자열의 앞뒤가 같다"를 의미한다. 즉, 뒤집은 후에도 여전히 같은 문자열이라는 뜻이다. 예를 들면 "abcdcba", "racecar"가 있다.
{: .prompt-general }

문자열을 반전하면 첫 번째 문자가 마지막 문자가 된다. 문자열이 반전된 후에도 동일하다는 것은 첫 번째 문자가 마지막 문자와 동일하고, 두 번째 문자가 마지막에서 두 번째 문자와 동일하다는 것을 의미한다. 여기서 투 포인터 기법을 사용하여 해당하는 모든 문자가 동일한지 확인할 수 있다. 먼저 두 개의 개별 포인터를 사용하여 첫 번째와 마지막 문자를 확인한다. 다음 문자 쌍을 확인하기 위해서는 포인터를 서로 한 위치씩 이동하기만 하면 된다. 포인터가 서로 만나거나, 일치하지 않는 지점을 찾을 때까지 계속 진행한다.

> `n`은 총 문자 수이므로 `n - i - 1`은 마지막, 마지막에서 두 번째, 마지막에서 세 번째 등의 문자에 해당한다. 입력이 0부터 시작하는 인덱스이므로, `-1`이 필요하다.
{: .prompt-general }

```cpp
bool checkIfPalindrome(string s) {
    int left = 0;
    int right = s.size() - 1;
    
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}
```

입력이 문자열이 아닌 문자 배열인 경우, 알고리즘이 변경되지 않는다는 점에 유의하자. 투 포인터 기법은 인덱스 변수가 추상적인 반복자(Iterable)을 따라 이동하는 한 작동할 것이다.

이 알고리즘은 $$O(n)$$에서 실행될 뿐만 아니라 $$O(1)$$ 공간만 사용하므로 매우 효율적이다. 입력이 제 아무리 크더라고, 항상 두 개의 정수 변수만 사용한다. 시간 복잡도는 $$O(n)$$인데, 이는 while 루프 반복이 각각 $$O(1)$$의 비용이 들고, 포인터가 서로 $$n$$만큼 떨어진 거리에서 시작하여 반복할 때마다 한 단계씩 가까워지기 때문에 while 루프 반복이 $$O(n)$$를 초과할 수 없기 때문이다.

---

> 예제 2: 고유 정수의 **정렬된** 배열과 목표 정수가 주어졌을 때, 목표와 합산되는 숫자 쌍이 있으면 `true`를 반환하고, 그렇지 않으면 `false`를 반환한다. 이 문제는 [Two Sum](https://leetcode.com/problems/two-sum/)과 유사하다. (단, Two Sum에서는 입력이 정렬되지 않는다).
>
> 예를 들어 `nums = [1, 2, 4, 6, 8, 9, 14, 15]`, `target = 13`이 주어지면, `4 + 9 = 13`이므로 true를 반환한다.
{: .prompt-general }

무차별 대입 (Bruce force) 솔루션은 모든 정수 쌍을 반복하는 것이다. 배열의 각 숫자는 다른 숫자와 짝을 이룰 수 있으므로 시간 복잡도는 $$O(n^2)$$가 되며, 여기서 $$n$$는 배열의 길이이다. 주어진 배열이 정렬되어 있기 때문에 투 포인터를 사용하여 시간 복잡도를 $$O(n)$$로 개선할 수 있다.

우선 예제 입력을 사용해보자. 투 포인터를 사용하여 먼저 첫 번째 숫자와 마지막 숫자를 살펴보자. 이들의 합은 `1 + 15 = 16`이다. `16 > target`이므로, 현재 합계를 더 작게 만들어야 한다. 따라서 `right` 포인터를 이동해야 한다. 이제 `1 + 14 = 15`가 되었다. 이번에도 합이 너무 크므로 right 포인터를 이동해야 한다. 이제 `1 + 9 = 10`이 되었다. 이번에는 합이 너무 작기 때문에 더 크게 만들어주기 위해 `left` 포인터를 이동하면 된다. `2 + 9 = 11 < target`이므로 다시 이동해야 한다. 마지막으로 `4 + 9 = 13 = target`이다.

이 알고리즘이 작동하는 이유는 숫자가 정렬되어 있기 때문에 left 포인터를 이동하면 left 포인터가 가리키는 값이 영구적으로 증가하게 된다 (`nums[left] = x`). 마찬가지로 right 포인터를 이동시키면 오른쪽 포인터가 가리키는 값이 영구적으로 감소한다(`nums[right] = y`). `x + y > target`인 경우, `x`는 증가만 가능하므로 `y`로 해를 구할 수 없다. 따라서 해가 존재한다면 `y`를 줄여야만 해를 찾을 수 있다. `x + y < target`인 경우에도 동일한 논리를 `x`에 적용할 수 있다.

```cpp
bool checkForTarget(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        // curr is the current sum
        int curr = nums[left] + nums[right];
        if (curr == target) {
            return true;
        }
        if (curr > target) {
            right--;
        } else {
            left++;
        }
    }

    return false;
}
```

이전 예제에서와 마찬가지로 이 알고리즘은 $$O(1)$$ 공간을 사용하며, 시간 복잡도는 $$O(n)$$이다.

---

## **다른 접근 방식**

첫 번째와 마지막 인덱스에서 포인터를 시작하여 서로를 향해 이동하는 이 방법은 투 포인터를 구현하는 방법 중 한가지일 뿐이다. "투 포인터"는 단지 아이디어일 뿐이며, 다양한 방법으로 구현할 수 있다. 다른 방법을 살펴보자. 다음 방법은 입력에 두 개의 반복자가 있는 문제(예: 두 개의 배열)에 적용할 수 있다.

> 모든 요소가 검사될 때까지 두 입력을 동시에 이동한다.
{: .prompt-general }

이 아이디어를 명령어로 변환해보자:

1. 각 반복자에 대해 하나씩 두 개의 포인터를 생성한다. 각 포인터는 첫 번째 인덱스에서 시작해야 한다.
2. 포인터 중 하나가 반복자의 끝에 도달할 때까지 while 루프를 사용한다.
3. 루프를 반복할 때마다 포인터를 앞으로 이동시킨다. 즉, 포인터 중 하나 또는 두 포인터 모두를 증가시킨다. 어떤 포인터를 이동할지 결정하는 것은 해결하려는 문제에 따라 달라진다.
4. 포인터 중 하나가 끝에 도달하면 while 루프가 중지되므로 루프가 완료될 때 다른 포인터는 해당 반복자의 끝에 있지 않을 것이다. 때로는 모든 요소를 반복해야 하는 경우가 있는데, 이 경우 두 반복자가 모두 소진되었는지 확인하기 위해 여기에 추가 코드를 작성해야 한다.

다음은 이 개념을 설명하는 의사 코드이다:

```cpp
function fn(arr1, arr2):
    i = j = 0
    while i < arr1.length AND j < arr2.length:
            문제에 따라 여기에서 몇 가지 논리를 수행하자
            여기에서 논리를 더 수행하여 다음 중 하나를 결정한다:
            1. i++
            2. j++
            3. Both i++ and j++

    // 4단계: 두 반복자가 모두 소진되었는지 확인한다.
    // 이 루프 중 하나만 실행된다는 점에 유의하자.
    while i < arr1.length:
        문제에 따라 여기에서 몇 가지 논리를 수행하자
        i++

    while j < arr2.length:
        문제에 따라 여기에서 몇 가지 논리를 수행하자
        j++
```

첫 번째 방법과 유사하게, 이 방법은 while 루프 내부의 작업이 $$O(1)$$인 경우 선형 시간 복잡도가 $$O(n + m)$$이고, 여기서 `n = arr1.length`, `m = arr2.length`이다. 이는 모든 반복에서 적어도 하나의 포인터를 앞으로 이동하고, 배열이 소진되지 않는 한 포인터를 `n + m`회 이상 앞으로 이동할 수 없기 때문이다. 몇 가지 예를 살펴보자.

---

> 예제 3: 정렬된 정수 배열 `arr1`과 `arr2`가 주어졌을 때, 두 배열을 결합하고 정렬된 새 배열을 반환한다.
{: .prompt-general }

가장 간단한 접근 방법은 먼저 두 입력 배열을 결합한 다음 정렬을 수해하는 것이다. `n = arr1.length + arr2.length`인 경우, 시간 복잡도는 $$O(n \cdot \log{}n)$$(정렬 비용)이 된다. 입력 배열이 정렬되지 않았다면 이는 좋은 접근 방식이겠지만, 정렬되어 있지 않기 때문에 투 포인터 기법을 활용하여 $$O(n)$$로 개선할 수 있다.

> 이 예제 앞의 설명에서 `n = arr1.length`, `m = arr2.length`라고 선언했다. 여기서는 `n = arr1.length + arr2.length`라고 한다. 왜일까? 빅오의 경우, 변수를 원하는 대로 정의할 수 있다는 점을 기억해보자. 이 경우 정렬 접근법의 시간 복잡도는 $$O((n + m) \cdot \log{}(m + n))$$가 되고, 우리가 다루려는 접근법의 시간 복잡도는 $$O(n + m)$$가 될 것이다. 실제로 차이가 있지는 않지만, 배열을 결합하기 때문에 총 길이가 상당한 수가 될 수도 있으므로, 이를 `n`으로 표현하는 것이 합리적이라는 점을 한 가지 근거로 들 수 있다.
{: .prompt-general }

우리는 한 번에 하나의 요소로 `답(ans)` 배열을 구축할 수 있다. 각 배열의 첫 번째 인덱스에서 투 포인터를 시작하고 그 요소를 비교한다. 각 반복마다 두 개의 값이 있다. 더 낮은 값이 답변에서 가장 앞에 오도록 하려면 해당 값을 답변에 추가하고 해당 포인터를 이동한다.

```cpp
vector<int> combine(vector<int>& arr1, vector<int>& arr2) {
    // ans is the answer
    vector<int> ans;
    int i = 0, j = 0;
    while (i < arr1.size() && j < arr2.size()) {
        if (arr1[i] < arr2[j]) {
            ans.push_back(arr1[i]);
            i++;
        } else {
            ans.push_back(arr2[j]);
            j++;
        }
    }
    
    while (i < arr1.size()) {
        ans.push_back(arr1[i]);
        i++;
    }
    
    while (j < arr2.size()) {
        ans.push_back(arr2[j]);
        j++;
    }
    
    return ans;
}
```

앞의 두 예와 마찬가지로 이 알고리즘은 $$O(n)$$의 시간 복잡도를 가지며 $$O(1)$$ 공간을 사용한다(출력을 여분의 공간으로 계산하지 않는 경우, 일반적으로는 계산하지 않는다).

---

> 예제 4: [서브시퀀스 인가?](https://leetcode.com/problems/is-subsequence/)
>
> 두 문자열 `s`와 `t`가 주어졌을 때, `s`가 `t`의 시퀀스이면 `true`를 반환하고 아니면 `false`를 반환한다.
>
> 문자열의 시퀀스는 원래 문자열에서 일부(또는 전혀) 문자를 삭제하여 얻을 수 있는 문자의 시퀀스이며, 나머지 문자의 상대적 순서는 유지해야 한다. 예를 들어, "ace"는 "abcdef"의 서브시퀀스이지만 "aec"는 그렇지 않다.
{: .prompt-general }

이 문제에선 간격이 허용된 상태에서 `s` 문자가 `t`에서 동일한 순서로 나타나는지 확인해야 한다. 예를 들어, `"abcde"`에 `"ace"`가 같은 순서로 포함되어 있기 때문에 `"ace"`는 `"abcde"`의 서브 시퀀스이며, 연속적이지 않다는 사실은 중요하지 않다.

우리는 투 포인터를 사용하여 이 문제를 선형 시간 내에 풀 수 있다. `s[i] == t[j]`를 찾았다면, 이는 `s`의 `i`위치에 있는 문자를 "찾았다"라는 의미이며, `i`를 증가시켜 다음 문자로 넘어갈 수 있다. 각 반복에서 무슨 일이 있어도 `j`를 증가시켜야 한다 (for 루프를 사용하여 이 알고리즘을 구현할 수도 있다). `s`의 모든 문자를 "찾을 수 있다"면, `s`는 `t`의 서브시퀀스이며, 이는 알고리즘의 마지막에서 `i == s.length`가 된다는 것을 의미한다.

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < s.size() && j < t.size()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        
        return i == s.size();
    }
};
```

앞의 모든 예제와 마찬가지로 이 솔루션은 $$O(1)$$ 공간을 사용한다. 시간 복잡도는 `s`와 `t`의 길이에 따라 선형이다.

---

## **마무리 노트**

첫 번째 방법에서는 첫 번째와 마지막 인덱스에서 포인터를 시작했지만 때로는 다른 인덱스에서 포인터를 시작해야 하는 문제가 발생할 수 있다. 두 번째 방법에서는 두 개의 다른 입력을 따라 투 포인터를 앞으로 이동했다. 때로는 입력 배열/스트링이 하나만 있을 수 있지만 여전히 첫 번째 인덱스에서 투 포인터를 모두 초기화하고 투 포인터를 모두 앞으로 이동한다.

투 포인터는 단지 두 개의 정수 변수를 사용하여 일부 반복자를 따라 이동하는 것을 의미한다. 이 글에서 살펴본 전략은 가장 일반적인 패턴이지만, 항상 문제에 접근하는 다른 방법을 찾아보시기 바란다. "쓰리 포인터"를 사용하는 문제도 있다.

> 투 포인터는 이 글에 소개된 내용보다 훨씬 더 많은 용도로 활용될 수 있다.
{: .prompt-general }

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4501/)
