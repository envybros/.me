---
title: "빅오(Big O) 소개"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-04 00:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

빅오(Big O)는 알고리즘의 계산 복잡도를 설명하는 데 사용되는 표기법이다. 여기서 계산 복잡도는 시간 복잡도와 공간 복잡도 두 부분으로 나뉜다.

- 시간 복잡도: 입력 크기를 기준으로 알고리즘을 실행해야 하는 시간
- 계산 복잡도: 입력 크기를 기준으로 알고리즘에 의해 할당되는 메모리의 양

> 대부분의 사람들이 공간 복잡도보다 시간 복잡도에 더 신경쓰지만, 사실은 둘 다 알아야 한다.
{: .prompt-general }

---

## **복잡도의 작동 방식**

복잡도는 **함수**로 설명할 수 있다. 이 함수(Big O)에 대한 인수의 범위는 얼마나 되어야 할까?

기본적으로 인수는 프로그래머가 정의하지만, 인수에 대한 입력이 변경될 때 변경될 수도 있는 관련 변수들을 모두 포함해야 한다. 우리가 가장 일반적으로 쓰는 변수는 다음과 같다: $$n$$ (대체로 배열의 길이를 나타낸다.)

우리가 코딩 테스트 환경에서 고려해야 할 몇 가지 내용이 있다. 예를 들어 **정수**를 다룰 때 값이 크면 클수록 *더하기*, *곱하기*, *출력*과 같은 연산은 많은 시간이 소요된다. 이론적으로는 맞는 말이다. 하지만 실제로는 그 차이가 매우 작기 때문에, 이 사실은 무시해도 상관없다. 정수의 배열이 입력으로 주어지면, 배열의 길이를 나타내는 변수는 $$n$$ 하나 뿐이다. 물론 우리는 다른 변수를 도입할 수도 있다. $$k$$를 사용하여 정수 배열의 평균값을 나타낼 수도 있다. 하지만 그 누구도 그렇게 하지는 않는다.

우리가 함수(Big O)로 표기할 때는 대문자 $$O$$로 묶는다. 다음은 복잡도의 예시이다:

- $$O(n)$$　
- $$O(n^2)$$　
- $$O(2^n)$$　
- $$O(\log{}n)$$　
- $$O(n \cdot m)$$　

> 여기서 $$m$$은 특별할 것 없이 그저 변수를 정의한 것이다. 예를 들어, "두 개의 배열이 입력으로 들어온다"라고 하는 문제가 있다고 해보자. 여기서 $$n$$은 첫번째 배열의 길이를 표현할 수 있고, 또 $$m$$은 다른 배열의 길이를 표현할 수 할 수 있다.
{: .prompt-general }

---

## **규칙**

이 함수(Big O)는 인수가 **극한의 값으로 향함**에 따라 알고리즘에 필요한 연산과 메모리의 양이 어떻게 증가하는지를 설명한다. 여기서 변수는 극한, 즉, 무한대로 향하기 때문에 **상수 값은 항상 무시된다.**

예를 들면: $$O(9999999n) = O(8n) = O(n) = O(\frac{n}{500})$$ 가 된다.

> 우리가 주목해야 할 점은 "입력의 크기에 따라 알고리즘이 어떻게 확장되는가"이다. 두 개의 알고리즘이 있다고 가정해보자. 하나는 $$O(100n)$$으로 실행되고, 다른 하나는 $$O(5n)$$으로 실행된다. 여기서 $$n$$의 값을 두 배로 늘리면 두 알고리즘 모두 똑같이 2배 더 오래걸릴 것이다. 따라서 두번째 알고리즘이 20배 더 빠르게 실행된다. 하지만, 두 알고리즘 모두 $$n$$에 따라 선형적으로 증가하기 때문에 두 알고리즘 모두 $$O(n)$$이 된다.
{: .prompt-general }

이는 **동일한** 변수의 항 사이에 덧셈이나 뺄셈이 있는 경우, 일부 항을 무시할 수 있다는 뜻이 된다. 예를 들어, $$O(2n + n^2 - 500) = O(n^2)$$에서 $$n$$이 극한 값으로 향할수록 $$2^n$$이 다른 두 항을 완전히 지배하기 때문이다.

알고리즘을 분석하고 시간과 공간의 복잡도를 도출할 수 있는 능력은 매우 중요한 기술이다. 우리가 지원할 회사의 면접관들은 우리가 단순히 코드를 외우거나, 복사한 것이 아니라 실제로 알고리즘을 이해하고 있는지 확인하기 위해 **항상 알고리즘의 복잡도를 물어볼 것**이다. 그러므로 우리가 알고리즘을 분석할 수 있는 능력을 갖춘다면, 알고리즘의 어떤 부분을 개선할 수 있는지 파악할 수 있게 된다.

> 최고의 복잡도는 "상수 시간" 또는 "상수 공간"인 $$O(1)$$이다. 이는 알고리즘이 입력에 관계없이 항상 동일한 양의 리소스를 사용한다는 것을 의미한다.
>
> 그러나 시간 복잡도가 일정하다고 해서 알고리즘이 반드시 빠르다는 의미는 아니다. 그저 알고리즘의 런타임이 입력 크기와 무관하다는 의미일 뿐이라는 점에 유의하자.
>
> $$O(50000000) = O(1)$$　
{: .prompt-general }

복잡도에 대해 이야기할 때는 대체로 다음 세 가지 경우가 있다:

- 최상 케이스 시나리오
- 평균 케이스
- 최악 케이스 시나리오

대부분의 알고리즘에서는 이 세 가지가 모두 동일하다. 하지만 일부 알고리즘에서는 이 세 가지가 전부 제각각일 수도 있다. 만약 우리가 알고리즘의 시간 혹은 공간 복잡도를 나타내기 위해 단 하나의 케이스만 선택해야 한다면 절대 최상의 시나리오를 선택하면 안된다. 최악의 시나리오를 사용하는 것이 가장 정확하다. 그리고 두 경우의 차이점에 대해 이야기할 수 있어야 한다.

---

## **시간 복잡도 분석하기**

의사 코드 (pseudo-code)의 몇 가지 알고리즘 예시를 살펴보고, 시간 복잡도에 대해 알아보자.

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    print(num)
}
```

이 알고리즘의 시간 복잡도는 $$O(n)$$이다. 각 for 루프의 반복마다 $$O(1)$$의 비용이 드는 출력을 수행한다. 여기서 for 루프는 n번 반복되므로 시간 복잡도는 $$O(1 \cdot n) = O(n)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    for (int i = 0; i < 500,000; i++) {
        print(num)
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n)$$이다. 내부 for 루프의 반복에서는 각 $$O(1)$$의 비용이 드는 출력을 수행한다. 그리고 이 for 루프는 500,000번 반복되므로 외부 for 루프 반복에는 각 $$O(500000) = O(1)$$의 비용이 든다. 여기서 외부 for 루프는 $$n$$번 반복되므로 시간 복잡도는 $$O(n)$$이 된다.

앞의 두 알고리즘은 기술적으로는 시간 복잡도가 동일하지만, 실제로는 두 번째 알고리즘이 첫 번째 알고리즘보다 **훨씬** 더 느리다. 시간 복잡도가 $$O(n)$$이라고 하는 것은 맞는 말이지만, 실용성과 이론의 차이에 대해 설명할 수 있는 것은 매우 중요한 일이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    for (int num2: arr) {
        print(num * num2)
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n^2)$$이다. 내부 for 루프 반복에서 곱셈과 출력을 수행하는데, 둘 다 $$O(1)$$의 비용이 든다. 그리고 내부 for 루프는 $$n$$번 실행되므로 외부 for 루프 반복에는 $$O(n)$$의 비용이 든다. 여기서 외부 for 루프는 $$O(n)$$번 실행되므로 시간 복잡도는 $$O(n \cdot n)=O(n^2)$$가 된다.

---

```cpp
// 길이가 n인 정수 배열 "arr"와 길이가 m인 "arr2"가 주어진다.

for (int num: arr) {
    print(num)
}

for (int num: arr) {
    print(num)
}

for (int num: arr2) {
    print(num)
}
```

이 알고리즘의 시간 복잡도는 $$O(n+m)$$이다. 처음 두 개의 for 루프는 모두 $$O(n)$$의 비용이 드는 반면, 마지막 for 루프는 $$O(m)$$의 비용이 든다. 따라서 시간 복잡도는 $$O(2n+m) = O(n+m)$$이 된다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int i = 0; i < arr.length; i++) {
    for (int j = i; j < arr.length; j++) {
        print(arr[i] + arr[j])
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n^2)$$이다. 내부 for 루프는 외부 for 루프가 현재 어떤 반복에 있는지에 따라 달라진다. 내부 for 루프가 처음 실행될 때는 n번 실행된다. 그리고 두 번째로 실행하면 $$n-2$$번, 그 다음에는 $$n-2$$번, $$n-3$$번 등의 순서로 실행된다.

즉, 총 반복 횟수는 $$1 + 2 + 3 + 4 + ... + n$$이며, 이 수열의 부분 합은 $$\frac{n \cdot (n+1)}{2} = \frac{n^2 + n}{2}$$이다. 빅오에서는 분자의 덧셈 항과 분모의 상수 항이 모두 무시되므로, $$O(n^2)$$이 된다.

---

## **로그 시간**

로그는 지수의 역연산이다. 시간 복잡도 $$O(\log n)$$을 로그 시간이라고 하며, 이는 매우 **빠르다**. 일반적인 시간 복잡도는 $$O(n \cdot \log n)$$으로, 대부분의 문제에서 상당히 빠르며 효율정인 정렬 알고리즘의 시간 복잡도이기도 하다.

일반적으로 로그의 밑변은 `2`가 된다. 즉, 입력의 크기가 `n`인 경우 알고리즘은 $$2^x=n$$인 `x`연산을 수행한다. 그러나 모든 로그는 상수 계수와 관련되어 있기 때문에 빅오의 경우 로그의 밑변의 값이 그리 중요하지는 않다. $$O(\log n)$$은 알고리즘의 어딘가에서 매 단계마다 입력이 백분율만큼 감소하고 있음을 의미한다. 이에 대한 좋은 예로 이진 탐색(Binary Search)을 들 수 있다. 이진 탐색은 $$O(\log n)$$ 시간 안에 실행되는 탐색 알고리즘이다. 이진 탐색에서는 처음에는 전체 입력(`n`개의 요소)을 고려한다. 첫 번째 단계 이후에는 `n / 2`개의 요소만 고려하게 된다. 두 번째 단계 이후에는 `n / 4`개의 요소만 고려하는 식으로 진행된다. 각 단계마다 검색 공간이 50%씩 줄어들기 때문에 시간 복잡도가 로그 수준으로 감소하게 된다.

---

## **공간 복잡도 분석**

배열이나 문자열과 같은 변수를 초기화할 때 알고리즘은 메모리를 할당한다. 입력에 사용된 공간은 계산하지 않으며 (입력 값을 직접 수정하는 것은 매우 나쁜 습관이다.), 면접관이 요청하지 않는 한 출력(답안)에 사용되는 공간도 계산하지 않는다.

> 아래 예제에서 코드는 공간 복잡도를 분석할 수 있도록 메모리를 할당할 것이다. 그러므로 할당하는 모든 것을 공간 복잡도의 일부로 간주할 것이다. (물론 "정답"은 없다.)
{: .prompt-general }

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    print(num)
}
```

이 알고리즘의 공간 복잡도는 $$O(1)$$이다. 할당되는 유일한 공간은 정수 변수 `num`이며, 이 값은 $$n$$에 대해 상수이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

Array doubledNums = int[]

for (int num: arr) {
    doubledNums.add(num * 2)
}
```

이 알고리즘의 공간 복잡도는 $$O(n)$$이다. `doubledNums` 배열은 알고리즘이 끝날 때 $$n$$개의 정수를 저장한다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

Array nums = int[]
int oneHundredth = n / 100

for (int i = 0; i < oneHundredth; i++) {
    nums.add(arr[i])
}
```

이 알고리즘의 공간 복잡도는 $$O(n)$$이다. 배열 `nums`는 배열에 처음 1% 의 숫자를 저장한다. 따라서 공간 복잡도는 $$O(\frac{n}{100}) = O(n)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"와 길이가 m인 "arr2"가 주어진다.

Array grid = int[n][m]

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr2.length; j++) {
        grid[i][j] = arr[i] * arr2[j]
    }
}
```

이 알고리즘의 공간 복잡도는 $$O(n \cdot m)$$이다. 공간이 $$n \cdot m$$인 그리드를 생성한다.

> 앞으로 시간과 공간 복잡도에 대해 광범위하게 다룰 예정이다. 이 개념이 낯설더라도 너무 걱정하지 않길 바란다. 꾸준히 연습을 하다보면 혼자서 알고리즘을 분석하는 데 점점 더 익숙해질 것이다.
{: .prompt-general }

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/)
