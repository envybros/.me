---
title: "배열(Array)과 문자열(string)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-07 01:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

알고리즘 문제에서 일차원 배열과 문자열은 둘 다 정렬된 요소 그룹을 나타낸다는 점에서 매우 유사하다. 대부분의 알고리즘 문제에서는 배열 또는 문자열이 입력으로 주어지기 때문에, 기본적인 연산에 익숙해지고 주요한 패턴을 익혀두는 것이 중요하다.

"배열(Array)"은 프로그래밍 언어마다 조금씩 다른 의미로 사용될 수 있다. 파이썬에서는 배열 대신 "리스트(List)"를 사용하는데, 이는 매우 유연하다. `arr = []`로 간단히 초기화할 수 있고, 저장할 데이터 타입이나 크기를 미리 정하지 않아도 된다. 반면 C++ 같은 언어에서는 배열의 크기와 데이터 유형을 미리 지정해야 하지만, 동적 배열을 위한 리스트도 제공한다. (예: C++의 `std::vector`)

> 엄밀히 말하면 배열은 크기를 바꿀 수 없다. 그러나 동적 배열, 즉 리스트는 크기 조절이 가능하다. 알고리즘 문제에서 '배열'에 관해 언급할 때, 대부분 동적 배열을 의미하는 경우가 많다. **이 글에서는 동적 배열이나 리스트에 대해 이야기하되, 간단히 "배열"이라는 용어를 사용하겠다.**
{: .prompt-general }

문자열 역시 언어에 따라 다르게 구현되어 있다. 파이썬과 자바에서의 문자열은 변경할 수 없는(immutable) 특성을 가지고 있다. 하지만 C++에서는 문자열을 수정할 수 있다. 코딩 테스트를 위해서는 사용하려는 언어의 배열과 문자열 특성을 잘 이해하는 것이 중요하다. 이 글에서는 모든 언어의 세부 사항을 다루진 않을 예정이니, 필요한 정보는 각자 찾아볼 것을 권장한다.

> 가변(mutable): 데이터를 변경할 수 있는 특성
>
> 불변(immutable): 데이터를 변경할 수 없는 특성
>
> 불변의 특성을 가진 변수를 수정하려면 그 변수 전체를 새로 만들어야 한다.
{: .prompt-general }

왜 우리는 가변성과 불변성에 주의를 기울여야 할까? 가변적인 배열 `arr = ["a", "b", "c"]`와 불변적인 문자열 `s = "abc"`가 주어져 있다고 가정하자. 만약 `"abd"`로 변경하고 싶다면, `arr[2] = "d"`로 쉽게 변경할 수 있지만, `s[2] = "d"`로는 변경할 수 없다. 문자열 s를 "abd"로 바꾸려면 전체 문자열을 다시 만들어야 한다. 이는 작은 문자열에서는 큰 문제가 되지 않을 수 있으나, 만약 100,000개의 문자로 이루어진 문자열에서 한 문자만 변경해야 한다면, 매번 전체를 다시 생성하는 것은 큰 오버헤드가 발생한다. 이러한 연산은 $$O(n)$$의 시간 복잡도를 가지게 되며, 여기서 $$n$$은 문자열의 길이를 나타낸다.

앞서 언급했듯, 대부분의 알고리즘 문제는 배열이나 문자열과 관련된 문제들입니다. 배열과 문자열은 매우 유용하고 다재다능한 데이터 구조이기 때문에 이와 관련된 문제 해결 방법을 모두 나열하기는 어렵다. 다음 몇 개의 글에서 이러한 문제들을 해결하기 위한 가장 흔하게 사용되는 기법들을 알아볼 것이다.

우선 배열과 문자열 연산의 복잡도에 대해 간단히 확인해보자:

| 연산 (Operation)              | 배열/리스트  | 문자열(불변)     |
|-------------------------------|-------------|-----------------|
| 끝에 추가 (Appending)          | $O(1)$      | $O(n)$          |
| 끝에서 빼기 (Popping)          | $O(1)$      | $O(n)$          |
| 끝이 아닌 곳에 삽입 (Insertion) | $O(n)$     | $O(n)$          |
| 끝이 아닌 곳에서 삭제 (Deletion)| $O(n)$     | $O(n)$          |
| 요소 수정 (Modifying)          | $O(1)$     | $O(n)$          |
| 임의의 위치 접근                | $O(1)$    | $O(1)$           |
| 요소 존재 여부 확인 (exists)    | $O(n)$    | $O(n)$           |

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4500/)
