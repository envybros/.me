---
title: "빅오(Big O) 소개"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-05 01:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

빅오 표기법은 알고리즘의 실행 성능을 설명하기 위한 방법이다. 주로 시간 복잡도와 공간 복잡도로 나누어 표현한다.

- 시간 복잡도: 알고리즘의 실행 시간을 입력 크기에 대해 나타낸 것
- 공간 복잡도: 알고리즘이 사용하는 메모리 양을 입력 크기에 대해 나타낸 것

> 대부분은 시간 복잡도에 초점을 맞추지만, 공간 복잡도 역시 중요하다.
{: .prompt-general }

---

## **복잡도의 표현**

복잡도는 **함수**를 통해 설명한다. 그렇다면 이 함수(빅오)에는 어떤 인자가 들어가야 하는가?

보통 인자는 프로그래머가 정의하며, 특히 입력 값이 변화할 때 어떻게 영향을 받는지를 나타내는 관련 변수들을 포함한다. 주로 사용하는 변수는 $$n$$인데, 이는 주로 배열의 길이를 나타낸다.

코딩 테스트 환경에서는 몇 가지 특성을 고려해야 한다. 예를 들어 정수를 처리할 때 값이 커질수록 기본 연산에 더 많은 시간이 소요될 수 있다는 이론이 있다. 하지만 실제로는 이 차이는 미미하기 때문에 크게 신경 쓰지 않아도 된다. 입력으로 정수 배열이 주어지면, 배열의 길이를 나타내는 변수는 주로 $$n$$이다. 물론 필요에 따라 다른 변수를 도입할 수 있다. 예를 들면 $$k$$로 배열 내 정수의 평균값을 표현할 수 있겠지만, 실제로는 그렇게 표현하는 경우는 드물다.

빅오 표기법을 사용할 때는 다음과 같이 대문자 $$O$$로 표현한다:

- $$O(n)$$　
- $$O(n^2)$$　
- $$O(2^n)$$　
- $$O(\log{}n)$$　
- $$O(n \cdot m)$$　

> 여기서 $$m$$은 특별한 변수는 아니다. 예를 들어 "두 개의 배열이 주어진다"는 문제 상황에서, $$n$$은 첫 번째 배열의 길이, $$m$$은 두 번째 배열의 길이로 사용할 수 있다.
{: .prompt-general }

---

## **규칙**

빅오 표기법은 알고리즘의 성능 변화를 설명할 때 사용된다. 이 때, 변수가 극한, 즉 무한대로 향하게 될 때 **상수 항은 무시**된다.

예를 들면: $$O(9999999n) = O(8n) = O(n) = O(\frac{n}{500})$$ 가 된다.

> 중요한 것은 "입력 크기가 증가할 때 알고리즘이 어떻게 확장되는가"이다. 두 개의 알고리즘이 있다고 가정해보자. 하나는 $$O(100n)$$으로 실행되고, 다른 하나는 $$O(5n)$$으로 실행된다. 여기서 $$n$$의 값을 두 배로 늘리면 두 알고리즘 모두 똑같이 2배의 시간이 걸릴 것이다. 하지만 두 알고리즘 모두 입력 크기 $$n$$에 따라 선형적으로 증가하기 때문에 두 알고리즘의 복잡도는 모두 $$O(n)$$이다.
{: .prompt-general }

복잡도를 표현할 때 **동일한** 변수의 항 사이에 덧셈이나 뺄셈이 있는 경우, 가장 큰 영향을 주는 항만을 고려한다. 예를 들어, $$O(2n + n^2 - 500) = O(n^2)$$에서 $$n^2$$항이 가장 큰 영향을 주므로 다른 항들은 무시된다.

알고리즘을 분석하고 그 성능을 예측하는 능력은 매우 중요하다. 면접에서도 이런 분석 능력을 확인하기 위해 종종 알고리즘의 복잡도에 관한 질문을 받게될 것이다.

> "상수 시간" 또는 "상수 공간" 복잡도는 $$O(1)$$로 표현된다. 이는 알고리즘의 성능이 입력 크기에 관계없이 일정하다는 것을 의미한다.
>
> 그러나 시간 복잡도가 일정하다고 해서 항상 알고리즘이 빠르다는 것은 아니다. 복잡도가 입력 크기와 무관하다는 것만 의미한다. ($$O(50000000) = O(1)$$)
{: .prompt-general }

알고리즘의 성능을 분석할 때 주로 고려하는 세 가지 시나리오는:

- 최적의 경우
- 평균적인 경우
- 최악의 경우

대부분의 알고리즘에서 최적, 평균, 최악의 경우의 성능은 동일하게 나타날 수 있다. 그러나 일부 알고리즘에서는 세 경우마다 성능이 다르게 나올 수 있다. 알고리즘의 시간 혹은 공간 복잡도를 나타낼 때 하나의 시나리오만을 기준으로 해야 한다면, 최적의 경우를 기준으로 하면 안 된다. 보통 **최악의 경우를 기준**으로 복잡도를 분석하는 것이 가장 정확하다. 그리고 각각의 경우에 대한 성능 차이점을 알고 있어야 한다.

---

## **시간 복잡도 분석하기**

의사 코드(pseudo-code)의 몇 가지 알고리즘 예시와 함께 시간 복잡도를 살펴보자.

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    print(num)
}
```

이 알고리즘의 시간 복잡도는 $$O(n)$$이다. 각 반복마다 $$O(1)$$의 비용이 드는 출력을 수행하므로 전체 시간 복잡도는 $$O(1 \cdot n) = O(n)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    for (int i = 0; i < 500,000; i++) {
        print(num)
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n)$$이다. 내부 for 루프는 각각 $$O(1)$$의 비용이 드는 출력을 수행한다. 이 for 루프는 500,000번 반복되므로 외부 for 루프의 각 반복에 대한 비용은 $$O(500000) = O(1)$$이다. 외부 for 루프는 $$n$$번 반복되므로 전체 시간 복잡도는 $$O(n)$$이 된다.

두 알고리즘은 시간 복잡도는 동일하나, 실제로는 두 번째 알고리즘이 첫 번째 알고리즘보다 **훨씬** 더 느리다. 시간 복잡도가 $$O(n)$$이라고만 해서는 그 차이를 설명할 수 없으므로, 실용성과 이론의 차이를 이해하는 것이 중요하다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    for (int num2: arr) {
        print(num * num2)
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n^2)$$이다. 내부 for 루프에서는 곱셈과 출력, 둘 다 $$O(1)$$의 비용이 든다. 내부 for 루프는 $$n$$번 반복되므로 외부 for 루프의 각 반복은 $$O(n)$$의 비용이 든다. 따라서 전체 시간 복잡도는 $$O(n \cdot n)=O(n^2)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"와 길이가 m인 "arr2"가 주어진다.

for (int num: arr) {
    print(num)
}

for (int num: arr) {
    print(num)
}

for (int num: arr2) {
    print(num)
}
```

이 알고리즘의 시간 복잡도는 $$O(n+m)$$이다. 처음 두 개의 for 루프는 각각 $$O(n)$$의 비용이 든다. 반면 마지막 for 루프는 $$O(m)$$의 비용이 든다. 따라서 전체 시간 복잡도는 $$O(2n+m) = O(n+m)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int i = 0; i < arr.length; i++) {
    for (int j = i; j < arr.length; j++) {
        print(arr[i] + arr[j])
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n^2)$$이다. 내부 for 루프의 반복 횟수는 외부 for 루프의 현재 위치에 따라 변한다. 내부 for 루프는 처음 실행될 때 n번 실행되며, 그 다음으로는 $$n-1$$번, $$n-2$$번, $$n-3$$번 등으로 줄어든다.

즉, 전체 반복 횟수는 $$1 + 2 + 3 + ... + n$$이며, 이 수열의 합은 $$\frac{n \cdot (n+1)}{2} = \frac{n^2 + n}{2}$$이다. 빅오 표기에서는 고차 항만을 고려하므로, $$O(n^2)$$이 된다.

---

## **로그 시간**

로그는 지수와 반대되는 개념이다(역연산). 시간 복잡도 $$O(\log n)$$은 로그 시간이라고 부르며 이는 매우 **빠른** 시간 복잡도를 의미한다. 일반적인 시간 복잡도는 $$O(n \cdot \log n)$$으로, 이는 효율적인 정렬 알고리즘의 시간 복잡도로도 사용된다.

보통 로그의 밑은 `2`를 사용한다. 따라서, 입력 크기가 `n`인 경우 알고리즘은 $$2^x=n$$을 만족하는 `x`번의 연산을 수행한다. 하지만 모든 로그는 상수 배율로 이루어져 있어 빅오 표기에서는 로그의 밑수가 중요하지 않다. $$O(\log{}n)$$은 알고리즘이 각 단계에서 입력 크기를 일정 비율로 줄여나간다는 것을 의미한다. 이에 대한 대표적인 예로 이진 탐색(Binary Search)이 있다. 이진 탐색은 $$O(\log{}n)시간에 수행되는 탐색 알고리즘으로, 각 단계에서 검색 범위를 반으로 줄여나간다(로그 수준으로 감소한다).

---

## **공간 복잡도 분석**

변수나 배열, 문자열을 초기화할 때 알고리즘은 메모리를 할당한다. 입력으로 사용된 메모리는 고려하지 않으며, (입력을 직접 수정하는 것은 좋지 않다.) 코딩 테스트 환경에서 따로 지시하지 않는 한 출력(결과)으로 사용된 메모리도 고려하지 않는다.

> 아래 예제는 공간 복잡도를 분석하기 위해 메모리를 할당하는 코드이다. 따라서 모든 메모리 할당은 공간 복잡도의 일부로 간주된다. (물론 "정답"은 없다.)
{: .prompt-general }

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    print(num)
}
```

이 알고리즘의 공간 복잡도는 $$O(1)$$이다. 할당되는 유일한 메모리는 정수 변수 `num`이고, 이 변수는 $$n$$과 상관없이 항상 동일한 메모리를 사용한다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

Array doubledNums = int[]

for (int num: arr) {
    doubledNums.add(num * 2)
}
```

이 알고리즘의 공간 복잡도는 $$O(n)$$이다. `doubledNums` 배열은 알고리즘이 종료될 때 $$n$$개의 정수를 포함하게 된다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

Array nums = int[]
int oneHundredth = n / 100

for (int i = 0; i < oneHundredth; i++) {
    nums.add(arr[i])
}
```

이 알고리즘의 공간 복잡도는 $$O(n)$$이다. `nums`배열은 배열의 처음 1%의 숫자만을 저장하게 된다. 그러나 최악의 경우를 고려할 때 공간 복잡도는 $$O(\frac{n}{100}) = O(n)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"와 길이가 m인 "arr2"가 주어진다.

Array grid = int[n][m]

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr2.length; j++) {
        grid[i][j] = arr[i] * arr2[j]
    }
}
```

이 알고리즘의 공간 복잡도는 $$O(n \cdot m)$$이다. `grid`는 $$n \cdot m$$ $$n \cdot m$$크기의 2차원 배열을 할당하게 된다.

> 우리는 시간 복잡도와 공간 복잡도에 대해 계속해서 학습할 예정이다. 처음에는 이해하기 어려울 수 있지만, 꾸준한 연습을 통해 알고리즘의 복잡도를 분석하는 능력을 키울 수 있다.
{: .prompt-general }

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/)
