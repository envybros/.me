---
title: "재귀(Recursion) 소개"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-05 00:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

재귀(Recursion)란, 일종의 문제 해결 방법이다. 재귀는 스스로를 호출하는 함수를 사용하여 구현할 수 있다.

재귀 알고리즘의 반대 개념은 반복 알고리즘이다(모든 반복 알고리즘은 재귀적으로 작성할 수 있다. [관련 내용](https://en.wikipedia.org/wiki/Computability_theory)). 반복 알고리즘은 for 루프와 while 루프를 사용하여 반복을 시뮬레이션하는 반면, 재귀 알고리즘은 함수 호출을 사용하여 동일한 로직을 시뮬레이션 한다.

1부터 10까지의 숫자를 출력한다고 해보자. 다음은 반복 알고리즘에 대한 의사 코드(pseudocode)이다:

```cpp
for (int i = 1; i <= 10; i++) {
    print(i)
}
```

다음은 재귀 알고리즘에 대한 의사 코드이다:

```cpp
function fn(i):
    print(i)
    fn(i + 1)
    return

fn(1)
```

`fn`을 호출할 때마다 `i`(1부터 시작하는)를 출력한 다음 다시 `fn`을 호출하는데, 다음 숫자의 출력을 위해 `i`값에 1을 더해준다.

> 첫 번째 함수 호출은 `1`을 출력한 다음 `fn(2)`를 호출한다. `fn(2)`에서는 `2`를 출력한 다음 `fn(3)`을 호출한다. 이런 방식으로 꼬리에 꼬리를 물고 반복된다.
{: .prompt-general }

하지만 이 코드는 실제로는 잘못된 코드이다. 혹시 문제가 보이는가? 이 코드에서는 함수 호출이 멈추지 않는다! 이 코드를 실행하면 자연수(양의 정수)가 무한히 출력될 것이다. `return`보다 `fn(i + 1)`이 앞에 오기 때문에 영원히 반환되지 못할 것이다.

재귀를 중단하기 위해선 **탈출 조건(Base Case)**라고 하는 것이 필요하다. 탈출 조건는 재귀 함수가 시작될 때 호출을 종료할 수 있는 조건을 의미한다.

```cpp
function fn(i):
    if i > 10:
        return

    print(i)
    fn(i + 1)
    return

fn(1)
```

> `fn(10)`을 호출한 후 `10`을 출력하고 `fn(11)`을 호출한다. `fn(11)` 호출에서는 탈출 조건을 발동시키고 반환된다. 이제 다시 `fn(10)` 호출로 돌아와서 다음 줄인 `return` 문으로 이동한다. 그리고 `fn(9)` 호출로 돌아가고, 결국 `fn(1)` 호출로 돌아간다. 이렇게 재귀 알고리즘이 종료될 때까지 계속 돌아가게 된다.
{: .prompt-general }

재귀에 대해 이해해야 할 중요한 사항은 코드가 실행되는 순서, 즉 컴퓨터가 명령을 실행하는 순서이다. 반복 알고리즘을 사용하면 위에서부터 시작하여 한 줄씩 진행하면 된다. 하지만 재귀를 사용하면 호출이 서로 연쇄적으로 이어지기 때문에 꽤 혼란스러울 수 있다. 이해를 위해 숫자를 다시 출력해볼텐데, 최대 3까지만 출력해볼 것이다. 그리고 또 다른 출력 문을 추가하고 번호도 추가해볼 것이다:

```cpp
function fn(i):
1.  if i > 3:
2.    return

3.  print(i)
4.  fn(i + 1)
5.  print(f"End of call where i = {i}")
6.  return

fn(1)
```

이 코드를 실행하면 다음과 같은 내용이 출력된다:

```cpp
// 1
// 2
// 3
// End of call where i = 3
// End of call where i = 2
// End of call where i = 1
```

보다시피 텍스트를 출력하는 줄은 역순으로 실행된다. 오리지널 호출인 `fn(1)`은 먼저 `1`을 출력한 다음, `2`를 출력하는 `fn(2)`를 호출하고, 3을 출력하는 `fn(3)`을 호출한 다름, `3`을 출력하는 `fn(4)`를 호출한다. **여기부터가 중요한 부분이다**: 재귀가 어떻게 "이동"하여 "위로" 올라가는지이다. `fn(4)`는 탈출 조건을 발동시켜 반환한다. 이제 `i = 3`인 함수 호출로 돌아왔고 **4번째 줄**이 끝났으므로, `"End of call where i = 3"`을 출력하는 **5번째 줄**로 이동한다. 이 줄이 실행되면 다음 줄인 `return`으로 이동한다. 이제 `i = 2`인 함수 호출로 돌아왔고, **4번째 줄**이 끝났으므로 다시 다음 줄로 이동하여 `"End of call where i = 2"`를 출력한다. 이 과정은 `fn(1)`에 대한 오리지널 함수 호출이 반환될 때까지 반복된다.

> 모든 함수 호출은 반환될 때까지 "존재"한다. 다른 함수 호출로 이동하면 이전 함수는 새 함수가 반환될 때까지 대기한다. 호출이 발생한 순서는 기억되며 함수 내의 줄은 순서대로 실행된다.
>
> 각 함수 호출에는 고유한 지역 범위도 있다. 따라서 위의 예에서 `f(3)`을 호출하면 동시에 3개 "버전"의 `i`가 존재한다. 첫 번째 호출은 `i = 1`, 두 번째 호출은 `i = 2`, 세 번째 호출은 `i = 3`이다. `f(3)` 호출에서 `i += 1`을 수행한다고 가정해보자. 그러면 `i`는 `4`가 되지만, `f(3)` 호출에서만 `4`가 된다. 다른 두 "버전"의 `i`는 서로 다른 범위에 있기 때문에 영향을 받지 않는다.
{: .prompt-general }

---

## 문제 분석하기

위 출력 예제는 사실 무의미하다. 단순히 숫자를 출력하려는 경우에는 for 루프를 사용하는 것이 더 낫다. 재귀가 빛을 발하는 곳은 문제를 "하위 문제"로 세분화하고, 그 해결책을 조합하여 원래 문제를 해결할 수 있을 때이다.

[피보나치수](https://en.wikipedia.org/wiki/Fibonacci_number)에 대해 살펴보자. 피보나치수는 `0, 1`로 시작하는 숫자의 시퀀스이다. 그 다음 각 숫자는 이전 두 숫자의 합으로 정의된다. 처음 몇 개의 피보나치수는 `0, 1, 1, 2, 3, 5, 8`이다. 보다 더 공식적으로는 다음과 같다.

$$F{n} = F_{n - 1} + F_{n - 2}$$

이를 **점화식 (recurrence relation)**이라고 하며, 각 요소를 서로 연결하는 방정식이다.

의사 코드를 사용하여 $$n^{th}$$ 피보나치수를 반환하는 함수 `F(n)`을 작성해보자. 재귀 함수를 사용하기 위해서는 탈출 조건이 필요하다는 것을 잊어선 안된다. 이 경우 탈출 조건은 명시적으로 정의된다. `F(0) = 0` 및 `F(1) = 1`이다.

```cpp
function F(n):
    if n <= 1:
        return n

    oneBack = F(n - 1)
    twoBack = F(n - 2)
    return oneBack + twoBack
```

`F(3)`을 찾고 싶다고 가정해보자. `F(3)`을 호출하면 다음과 같은 흐름이 표시되며, 각 들여쓰기 수준은 함수 호출의 범위를 나타낸다:

```cpp
oneBack = F(2)
    oneBack = F(1)
        F(1) = 1
    twoBack = F(0)
        F(0) = 0
    F(2) = oneBack + twoBack = 1
twoBack = F(1)
    F(1) = 1
F(3) = oneBack + twoBack = 2
```

보다시피 오리지널 문제 `F(3)`을 두 개의 작은 하위 문제인 `F(2)`와 `F(1)`로 분해했다. 점화식과 탈출 조건을 결합하여 하위 문제를 풀고, 그 해를 사용하여 원래 문제를 해결할 수 있다.

재귀 함수가 **주어진 입력에 대해 해결하려는 문제에 대한 답을 반환**하도록 하는 것이 재귀의 가장 일반적인 용도이다. 이 예제에서 주어진 입력에 대해 해결하려는 문제는 "$$n^{th}$$ 피보나치수는 무엇인가?"이다. 따라서 입력 $$n$$에 따라 피보나치 수를 반환하도록 함수를 설계했다. 우리는 탈출 조건과 점화식을 결정하면 함수를 쉽게 구현할 수 있다.

이 아이디어를 따르면 하위 문제를 쉽게 풀 수 있다. 100번째 피보나치수를 원한다면, 정의에 따라 99번째와 98번째 피보나치수의 합이라는 것을 알 수 있다. `F(100)`에 대한 함수 호출에서 `F(99)`와 `F(98)`을 호출하면 해당 숫자를 얻을 수 있다는 것을 우리는 이제 알고 있다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4655/)
