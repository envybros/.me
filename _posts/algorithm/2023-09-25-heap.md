---
title: "힙 (Heap)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-24 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

힙은 [우선 순위 큐](https://en.wikipedia.org/wiki/Priority_queue)의 구현체인 자료 구조다.

우선 순위 큐가 추상 자료 구조임을 유의하라. 힙은 우선 순위 큐를 구현하는 여러 방법 중 하나다. 그러나 사람들은 종종 두 용어를 혼용하여 사용한다. 이 강좌에서는 "힙"이라는 용어를 사용할 것이다.

힙은 요소를 저장하는 컨테이너이며, 다음 작업을 지원한다:

- 요소 추가: $$O(\log{}n)$$
- 최소 요소 제거: $$O(\log{}n)$$
- 최소 요소 찾기: $$O(1)$$

> 힙은 최대 요소를 찾는 것 대신 최소 요소를 찾을 수도 있다. 힙이 최소 요소를 찾거나 제거하도록 설정된 경우, 이를 최소 힙이라고 한다. 최대 요소를 찾거나 제거하도록 설정된 경우, 이를 최대 힙이라고 한다.
{: .prompt-general }

상수 시간에 최대/최소 요소를 찾으면서, 이 기능을 변경을 통해 유지하는 데 로그 시간만 필요하다는 것은 힙을 굉장히 강력한 자료 구조로 만든다.

---

## **힙은 어떻게 구현되는가?**

해시 맵과 마찬가지로, 모든 주요 프로그래밍 언어는 힙을 지원할 것이므로 스스로 구현할 필요가 없다. 알고리즘 문제를 해결하는 관점에서는 인터페이스에 대해서만 신경 쓰면 되며, 구현 방식은 중요하지 않다. 하지만 해시 맵과 마찬가지로, 면접에서 이에 대해 물어볼 경우를 대비해 구현을 이해하는 것이 좋다.

> 간결함을 위해 이 문서에서는 최소 힙에 대해 이야기할 것이지만, 최대 힙에 대한 논리도 동일하다.
{: .prompt-general }

힙을 구현하는 데는 여러 가지 방법이 있지만, 가장 인기 있는 방법은 배열을 사용하는 **이진 힙**이다. 트리와 그래프 장에서, 이진 트리가 일반적으로 `node` 객체로 구현된다는 것을 보았다.

이진 힙은 배열만으로 이진 트리를 구현한다. 개념은 배열의 각 요소가 트리의 노드라는 것이다. 트리의 가장 작은 요소는 루트이며, 다음 속성이 모든 노드에서 유지된다: `A`가 `B`의 부모인 경우, `A.val <= B.val`이다. 이 속성이 루트가 가장 작은 요소임을 직접적으로 의미한다는 점에 유의하라.

> 또 다른 제약은 트리가 [완전 트리](https://en.wikipedia.org/wiki/Binary_tree#complete)여야 한다는 것이다.
{: .prompt-general }

부모-자식 관계는 인덱스와 수학을 사용하여 수행된다. 인덱스 `0`의 첫 번째 요소는 루트이며, 인덱스 `1`과 `2`의 요소는 루트의 자식이다. 인덱스 `3`과 `4`의 요소는 인덱스 `1`의 요소의 자식이며, 인덱스 `5`와 `6`의 요소는 인덱스 `2`의 요소의 자식이다. 노드가 인덱스 `i`에 있으면 그 자식은 인덱스 `2i + 1`과 `2i + 2`에 있다. 요소가 추가되거나 제거될 때, `parent.val <= child.val`의 앞서 언급한 속성을 유지하기 위한 작업이 수행된다. 필요한 작업 수는 힙의 요소 수에 대해 로그배으로 증가하며, 이 과정을 "버블링 업"이라고 한다.

![heap](heap.png)

> 기존 요소의 배열도 선형 시간에 힙으로 변환할 수 있지만, 이 과정은 복잡하다. 다행히 일부 주요 프로그래밍 언어에는 이를 수행하는 내장 메서드가 있다.
>
> 기억해야 할 점: 힙이 어떻게 구현되는지에 대해 너무 걱정할 필요는 없다. 중요한 것은 인터페이스를 이해하는 것이다. 완결성을 위해 이 문서에 구현 세부 사항을 포함시켰다.
{: .prompt-general }

많은 문제에서 힙을 사용하면 알고리즘의 시간 복잡도가 $$O(n^2)$$에서 $$O(n \cdot \log{}n)$$으로 향상될 수 있어, 이는 엄청난 개선이다(`n = 1,000,000`인 경우, `50,000`배 빠르다). 반복적으로 무언가의 최대값 또는 최소값을 찾아야 할 때 힙은 훌륭한 옵션이다.

---

## **인터페이스 가이드**

다음은 주요 언어에서 힙에 대한 인터페이스를 빠르게 살펴보는 가이드이다:

> 참고: 일부 언어는 기본적으로 최소 힙을 구현하는 반면, 일부는 최대 힙을 기본으로 구현한다.
>
> 숫자를 다루고 있고 사용하는 언어가 구현하는 힙의 반대 유형을 다루고 싶다면, 모든 숫자에 `-1`을 곱하는 것이 간단한 방법이다.
{: .prompt-general }

```cpp
// C++에서는 std::priority_queue를 사용할 것이다.
// 기본적으로 이는 최대 힙을 구현한다.
priority_queue<int> heap;

// 힙에 추가
heap.push(1);
heap.push(2);
heap.push(3);

// 최대 요소 확인
heap.top(); // 3

// 최대 요소 제거 (Pop)
heap.pop();

// 크기 얻기
heap.size(); // 2

// 보너스: 벡터를 선형 시간에 힙으로 변환
priority_queue<int> heap(nums.begin(), nums.end());
```

---

다음은 힙/우선 순위 큐 사용을 보여주는 인터랙티브한 예제이다.

```cpp
int main() {
    // 참고: C++의 priority_queue는 기본적으로 최대 힙을 구현한다.
    
    vector<int> nums = {67, 341, 234, -67, 12, -976};
    priority_queue<int> heap(nums.begin(), nums.end());
    
    heap.push(7451);
    heap.push(-5352);
    
    // 숫자들은 정렬된 순서로 출력될 것이다
    while (!heap.empty()) {
        cout << heap.top() << endl;
        heap.pop();
    }
}
```

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/708/heaps/4638/)

<!--

{: .prompt-general }

-->