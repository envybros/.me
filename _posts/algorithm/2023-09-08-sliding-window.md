---
title: "슬라이딩 윈도우 (Sliding window)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-08 01:20
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

> 슬라이딩 윈도우는 투 포인터 기법과 마찬가지로 배열과 문자열에서 동일한 방식으로 작동하며, 중요한 점은 이를 적용할 대상이 반복 가능한 객체(Iterable)여야 한다는 것이다. 간결함을 위해 이 글에서는 주로 **배열**을 예로 들겠지만, 동일한 로직이 문자열에도 적용될 수 있다.
{: .prompt-general }

슬라이딩 윈도우는 배열 관련 문제를 풀 때 자주 사용되는 접근 방식 중 하나이다. 실제로 슬라이딩 윈도우는 투 포인터를 이용하여 구현되곤 한다! 설명하기 전에 **부분 배열**의 개념을 알아둘 필요가 있다.

### **부분 배열(Subarray)**

배열이 주어졌을 때 **부분 배열**은 해당 배열의 연속적인 구간을 의미한다. 모든 요소는 원래 배열의 순서를 유지하며 연속적으로 나열되어야 한다. 예를 들어, 배열 `[1, 2, 3, 4]`에서 가능한 부분 배열(길이 별로 그룹화)은 다음과 같다:

- `[1]`, `[2]`, `[3]`, `[4]`
- `[1, 2]`, `[2, 3]`, `[3, 4]`
- `[1, 2, 3]`, `[2, 3, 4]`
- `[1, 2, 3, 4]`

**부분 배열은 시작과 끝의 두 인덱스로 정의된다.** 예를 들면, 배열 `[1, 2, 3, 4]`에서 부분 배열 `[2, 3]`의 시작 인덱스는 `1`이며 끝 인덱스는 `2`이다. 시작 인덱스를 **왼쪽 경계(left bound)**, 끝 인덱스를 `오른쪽 경계(right bound)`라 부를 것이다. 이 문맥에서 부분 배열을 "윈도우"라고도 표현한다.

![subarray](subarray.png)

---

## **슬라이딩 윈도우 활용 시기**

슬라이딩 윈도우 기법은 부분배열 관련 문제를 효과적으로 해결하는 데 유용하게 사용될 수 있다. 이러한 문제 유형을 어떻게 파악할 수 있는지 알아보자.

**첫 번째**, 문제에서는 부분배열이 "유효하다"는 기준을 명시적 또는 암시적으로 제시한다. 유효한 부분배열의 조건은 크게 두 가지로 나뉜다:

1. 제약 조건 지표(A constraint metric): 부분배열의 특성 중 하나로, 합계, 고유한 요소의 개수, 특정 요소의 빈도 등이 될 수 있다.
2. 제약 조건 지표에 대한 수치적 한계: 부분배열이 유효하다고 판단되기 위한 제약 조건 지표의 값이다.

예를 들어, 부분배열의 합이 `10` 이하인 경우를 유효하다고 본다면, 제약 조건 지표는 부분배열의 합이고, 수치적 한계는 `<= 10`이 될 것이다. 부분배열의 합이 `10` 이하일 경우 해당 부분배열은 유효하다고 간주된다.

**두 번째**, 문제에서는 특정 형태의 유효한 부분배열을 찾는 것을 요구한다.

1. 가장 흔한 요구사항은 **최적의** 부분배열을 찾는 것이다. 이때 문제는 어떤 부분배열이 다른 것보다 **우수한지**에 대한 기준을 제시한다. 예를 들어, **가장 긴** 유효한 부분배열을 찾는 문제 등이 있다.
2. 또 다른 흔한 요구는 유효한 부분배열의 총 개수를 파악하는 것이다. 이 글의 후반부에서 해당 내용에 대해 더 자세히 살펴보겠다.

> 문제 설명에서 부분배열에 대한 내용이 나올 때마다 해당 설명을 분석하여 슬라이딩 윈도우 기법이 적절한지 확인하자. 위에서 언급한 특징들을 발견한다면, 이 기법을 사용하기 좋은 문제일 것이다.
{: .prompt-general }

다음은 슬라이딩 윈도우 기법을 활용하는 문제의 예시들이다:

- 합이 `k` 이하인 가장 긴 부분배열 찾기
- 최대 하나의 `"0"`만 포함된 가장 긴 부분 문자열 찾기
- `k`보다 작은 곱을 갖는 부분배열의 총 개수 찾기

---

## **알고리즘**

슬라이딩 윈도우의 기본 개념은 유효한 부분배열**만**을 고려하는 것이다. 부분 배열은 왼쪽 경계(첫 번째 요소의 인덱스)와 오른쪽 경계(마지막 요소의 인덱스)로 정의되므로 이 점을 기억하자. 슬라이딩 윈도우에서는 `left`와 `right` 두 변수를 유지하며, 그 시점에서 고려하고 있는 현재 부분 배열을 표현한다.

처음에는 `left = right = 0`으로 시작한다. 이때 우리가 보는 첫 번째 부분배열은 배열의 첫 번째 요소 자체이다. "윈도우"의 크기를 확장하기 위해 `right`를 증가시킨다. `right`를 증가시키면, 윈도우에 새 요소가 "추가"된다는 의미다.

하지만 새 요소를 추가하고 나서 부분배열이 유효하지 않게 되면 어떻게 될까? 윈도우가 다시 유효해질 때까지 일부 요소를 "제거"해야 한다. 요소를 "제거"하기 위해서는 `left`를 증가시켜 윈도우를 줄이면 된다.

요소를 추가하거나 제거하는 과정에서 윈도우가 왼쪽에서 오른쪽으로 "슬라이딩"한다. 윈도우의 크기는 계속 변하며, 유효하지 않을 때까지 최대한 확장된 후 다시 축소된다. 그러나 입력의 끝에 도달할 때까지 항상 오른쪽으로 이동한다.

![Subarray2](subarray2.png)

이 알고리즘이 어떻게 작동하는지 구체적인 예로 살펴보자. 양수로 이루어진 배열 `nums`와 정수 `k`가 주어졌을 때, 합이 `k`보다 작거나 같은 가장 긴 부분배열의 길이를 찾는 상황을 생각해보자. 예를 들면, `nums = [3, 2, 1, 3, 1, 1]`, `k = 5`라고 하자.

처음에 `left = right = 0`이므로, 윈도우는 첫 번째 요소 `[3]`만을 포함한다. 이제 제약 조건을 만족시키기 위해 오른쪽으로 확장해본다. `left = 0, right = 2`가 되면, 윈도우는 `[3, 2, 1]`이 된다. 이때 합은 `6`이므로 `k`보다 크다. 그러므로 제약 조건을 다시 만족시키기 위해 왼쪽에서 윈도우를 축소해야 한다. 요소 하나를 제거하면 `[2, 1]`로 윈도우가 다시 유효한 상태가 된다.

`3`을 제거한 이유는 무엇일까? 입력 배열에는 양수만 포함되어 있으므로, 부분배열이 길어질수록 합도 커진다. `[3, 2, 1]`의 합이 이미 크다는 것을 알기 때문에, 오른쪽에서 요소를 더 추가하면 합이 더 커진다. 따라서, 이 `3`을 유지하게 되면 유효한 윈도우를 만들 수 없다. 이런 이유로 `3`은 무시해도 된다.

---

## **구현**

슬라이딩 윈도우의 작동 원리를 이해했으니, 이를 구현하는 방법에 대해 알아보자. 이 부분에서는 이전 예제 (합이 `k`보다 작거나 같은 가장 긴 부분배열 찾기)를 활용해볼 것이다.

위에서 언급한 대로 **제약 조건 지표**을 설정해야 한다. 이 예제에서의 제약 조건 지표는 윈도우 내의 합계다. 요소를 추가하거나 제거할 때, 윈도우의 합계를 어떻게 업데이트할까? 윈도우의 내용을 별도의 배열에 저장하는 것이 한 방법이다. 오른쪽에서 요소를 추가할 때마다 그 배열에도 추가하며, 왼쪽에서 요소를 제거할 때마다 그 배열에서도 해당 요소를 제거한다. 그렇게 하면, 그 배열에 있는 요소들의 합을 계산함으로써 현재 윈도우의 합계를 쉽게 구할 수 있다.

하지만, 요소를 제거하고 윈도우의 합을 계산하기 위해서는 $$O(n)$$의 시간이 소요되므로 비효율적이다. 더 효율적인 방법은 무엇일까?

사실, 윈도우의 내용을 별도의 배열에 저장할 필요는 없다. 현재 합계를 유지하는 변수 `curr`만 있으면 충분하다. 오른쪽에서 새 요소를 추가할 때 `curr += nums[right]`를 실행하면 되고, 이렇게 하면 연산은 모두 $$O(1)$$에서 처리된다.

그렇다면, `left`와 `right` 포인터를 어떻게 이동시킬까? 윈도우를 확장하고자 할 때, 윈도우가 항상 오른쪽으로만 슬라이딩될 수 있다는 것을 기억하자. 그렇기 때문에 `right` 포인터는 계속해서 앞으로 이동한다. `right` 포인터를 이동시키기 위해서는 for 루프를 사용하면 되며, 매 반복마다 `nums[right]` 요소를 윈도우에 추가한다.

그렇다면 `left` 포인터는 어떻게 조절할까? `left` 포인터를 이동시키면 윈도우 크기가 줄어든다. 윈도우의 크기를 줄이는 것은 윈도우가 유효하지 않을 때만 해야 한다. `curr`를 통해 `curr <= k` 조건을 확인함으로써 현재 윈도우의 유효성을 쉽게 판단할 수 있다. 만약 새로운 요소를 추가했는데 윈도우가 유효하지 않다면, 왼쪽에서 여러 요소를 제거해야 할 수도 있다. 예를 들어 `nums = [1, 1, 1, 3]`, `k = 3`인 경우, `3`을 윈도우에 추가하면 윈도우가 유효하지 않게 된다. 이를 유효하게 만들기 위해서는 왼쪽에서 세 요소를 모두 제거해야 한다.

따라서, 윈도우에서 요소를 제거하기 위해 while 루프를 사용해야 한다. 조건은 `while (curr > k)` (윈도우가 유효하지 않은 경우)로 설정한다. 요소를 제거하려면 `curr -= nums[left]`를 실행하고, while 루프의 각 반복마다 `left`를 하나씩 증가시킨다.

마지막으로, 결과를 어떻게 업데이트할 것인가? 각 for 루프의 반복마다, while 루프 이후 현재 윈도우는 유효하다. 여기서 결과를 업데이트하는 코드를 작성하면 된다. 윈도우의 길이는 `right - left + 1`로 계산된다.

아래는 이 모든 과정을 반영한 의사 코드이다:

```cpp
function fn(nums, k):
    left = 0
    curr = 0
    answer = 0
    for (int right = 0; right < nums.length; right++):
        curr += nums[right]
        while (curr > k):
            curr -= nums[left]
            left++

        answer = max(answer, right - left + 1)

    return answer
```

다음은 일반 템플릿에 대한 의사 코드이다:

```cpp
function fn(arr):
    left = 0
    for (int right = 0; right < arr.length; right++):
        // arr[right]에 있는 요소를 윈도우에 "add"하는 로직을 수행한다.

        while WINDOW_IS_INVALID:
            // 윈도우에서 arr[left]의 요소를 "remove"하는 로직을 수행한다.
            left++

        // 몇 가지 로직을 수행하여 답을 업데이트한다.
```

---

## **슬라이딩 윈도우의 효율성**

배열에는 얼마나 많은 부분배열이 있을까? 배열의 길이가 `n`일 때, 길이 `1`의 부분배열은 `n`개, 길이 `2`의 부분배열은 `n-1`개, 길이 `3`의 부분배열은 `n-2`개, 이런 식으로 계속해 길이 `n`의 부분배열이 `1`개 남게 된다. 이를 통해 $$\sum_{k=1}^{n} k = \frac{n \cdot (n + 1)}{2}$$부분 배열이 있다는 것을 알 수 있다. 따라서 모든 부분배열을 조사하는 알고리즘이 $$O(n^2)$$의 시간 복잡도를 갖게 되며, 이는 일반적으로 매우 비효율적이다. 반면, 슬라이딩 윈도우 방식은 최대 $$2n$$번의 윈도우 이동을 보장한다. 오른쪽 포인터는 최대 $$n$$번, 왼쪽 포인터는 최대 $n$번 이동할 수 있기 때문이다. 따라서 슬라이딩 윈도우 알고리즘의 시간 복잡도는 훨씬 빠른 $$O(n)$$이 된다.

> for 루프 내에 while 루프가 있긴 하지만, 전체 시간 복잡도가 $$O(n^2)$$이 아닌 $$O(n)$$이 되는 이유는 while 루프가 전체 실행 동안 최대 $$n$$번만 돌게 되기 때문이다. 만약 while 루프가 for 루프의 한 번의 반복에서 `n`번 돌게 되면, 다른 반복에서는 실행되지 않게 될 것이다. 이런 방식의 시간 복잡도 분석을 분할 상환 분석([amortized analysis](https://en.wikipedia.org/wiki/Amortized_analysis))이라고 한다.
{: .prompt-general }

다음은 슬라이딩 윈도우의 몇 가지 예제이다.

---

> **예제 1**: 양의 정수 `n`과 정수 배열 `k`가 주어졌을 때, 합이 `k` 이하인 가장 긴 부분배열의 길이를 찾아보자. 이 문제는 위에서 언급한 바와 같다.
{: .prompt-general }

`curr`라는 변수를 사용하여 현재 윈도우의 합계를 추적할 것이다. 문제에서는 합계가 `k` 이하인 부분배열을 찾아야 하므로, `curr <= k` 조건을 유지해야 한다. 예를 들어, `nums = [3, 1, 2, 7, 4, 2, 1, 1, 5]`, `k = 8`인 경우를 살펴보자.

처음에는 윈도우가 비어 있지만, `[3, 1, 2]`까지 확장할 수 있다. 하지만, `7`을 추가하면 합계가 넘치게 된다. 따라서 합계가 `8` 이하가 될 때까지 윈도우를 줄여나가야 한다. 이 과정에서 윈도우는 결국 `[7]`만 남게 된다. 다음에 `4`를 추가하면 다시 합계가 초과하므로 `7`을 제거하고, `[4]`만 남게 된다. 이후 `[4, 2, 1, 1]`까지 확장할 수 있지만, 다음 요소를 추가하면 다시 합계가 초과한다. 합계가 다시 `8` 이하가 될 때까지 윈도우에서 요소를 제거하면, `[1, 1, 5]`가 남게 된다. 그 결과, 가장 긴 부분배열은 `[4, 2, 1, 1]`로, 그 길이는 `4`이다.

오른쪽 경계를 이동시켜 요소를 추가할 때 `curr`에 값을 더하고, 왼쪽 경계를 이동시켜 요소를 제거할 때는 `curr`에서 값을 뺀다. `curr > k`인 경우 요소를 제거하여 이 조건을 만족시키게 해야 한다.

```cpp
int findLength(vector<int>& nums, int k) {
    // curr is the current sum of the window
    int left = 0, curr = 0, ans = 0;
    for (int right = 0; right < nums.size(); right++) {
        curr += nums[right];
        while (curr > k) {
            curr -= nums[left];
            left++;
        }
        
        ans = max(ans, right - left + 1);
    }
    
    return ans;
}
```

`left`에서 시작하여 `right`에서 끝나는 부분 배열의 길이는 `right - left + 1`이다. 앞서 언급했듯이, 이 알고리즘의 시간 복잡도는 for 루프 내에서 수행되는 모든 작업이 $$O(1)$$ 복잡도를 가지기 때문에 $$O(n)$$이며, 여기서 `n`은 배열의 길이다. 3개의 정수 변수만 사용하기 때문에 공간 복잡도는 상수다.

---

> **예제 2**: 이진 문자열 `s` (`"0"`과 `"1"`만 포함된 문자열)이 주어진다. 최대 하나의 `"0"`을 선택하여 `"1"`로 바꿀 수 있다. 이때, "1"만 포함하는 가장 긴 부분 문자열의 길이는 얼마일까?
>
> 예를 들어 `s = "1101100111"`가 주어지면 답은 `5`이다. 인덱스 2에서 `"0"`을 `"1"`로 바꾸면 문자열은 `1111100111`이 된다.
{: .prompt-general }

이 문자열에는 `"1"`과 `"0"`만 포함될 수 있다. 따라서 이 문제를 다르게 바라보면 "**최대 하나**의 `"0"`을 포함하는 가장 긴 부분문자열은 무엇일까?"가 된다. 조건이 `window.count("0") <= 1`인 슬라이딩 윈도우를 사용하면 쉽게 해결할 수 있다. 현재 윈도우에 몇 개의 "0"이 포함되어 있는지 확인하는 정수 curr를 사용한다.

```cpp
int findLength(string s) {
    // curr is the current number of zeros in the window
    int left = 0, curr = 0, ans = 0;
    for (int right = 0; right < s.size(); right++) {
        if (s[right] == '0') {
            curr++;
        }
        
        while (curr > 1) {
            if (s[left] == '0') {
                curr--;
            }
            left++;
        }
        
        ans = max(ans, right - left + 1);
    }
    
    return ans;
}
```

이전 예제와 마찬가지로, 이 문제는 각 루프 반복에서 수행되는 작업이 일정하게 나누어지기 때문에 $$O(n)$$ 시간으로 실행되며, 여기서 $$n$$은 `s`의 길이다. 몇 개의 정수 변수만 사용되므로 이 알고리즘은 $$O(1)$$ 공간을 사용한다.

---

## **부분 배열의 수**

어떤 제약 조건에 맞는 **부분 배열의 수**를 요구하는 문제에서도 슬라이딩 윈도우를 사용할 수 있다. 그런데 부분 배열의 수를 계산하려면 깔끔한 수학적 접근 방식이 필요하다.

슬라이딩 윈도우 알고리즘을 사용하고 있고 현재 윈도우 `(left, right)`가 있다면, 인덱스 `right`에서 끝나는 유효한 윈도우는 몇 개일까?

현재 윈도우는 `(left, right)`, `(left + 1, right)`, `(left + 2, right)`, `(right, right)` (오른쪽 요소만 포함) 등이다.

오른쪽 경계를 수정한 다음 왼쪽 경계를 포함하여 `left`와 `right` 사이의 값을 선택할 수 있다. 그러므로 인덱스 `right`에서 끝나는 유효한 윈도우의 수는 `right - left + 1`과 같다.

> **예제 3**: [K보다 작은 부분 배열의 곱](https://leetcode.com/problems/subarray-product-less-than-k/)
>
> 양의 정수 `nums`의 배열과 정수 `k`가 주어졌을 때, 부분 배열에 있는 모든 요소의 곱이 반드시 `k`보다 작은 부분 배열의 수를 반환한다.
>
> 예를 들어 입력 `nums = [10, 5, 2, 6], k = 100`이 주어지면 답은 `8`이다. `k`보다 작은 곱을 가진 부분 배열은 다음과 같다:
>
> `[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]`
{: .prompt-general }

방금 배운 내용을 이 예제를 통해 확인해 보면, 인덱스 `2`에 도달했을 때 곱이 너무 커져서 가장 왼쪽에 있는 요소 `10`을 제거해야 한다. 이제 윈도우는 유효하고 길이는 `2`가 된다. 따라서 여기서 끝나는 `2`개의 유효한 부분 배열이 있다(`[2]` 및 `[5, 2]`).

이전 예제에서 루프 이후에 답(가장 긴 길이)을 업데이트했던 것을 기억하자. 윈도우가 유효해야 한다. 여기서는 윈도우의 현재 크기를 답에 추가하면 된다. 윈도우가 유효하다는 것의 제약 조건은 곱이 `k`보다 작아야 한다는 것이다.

또한 `k <= 1`이면 유효한 윈도우를 가질 수 없으므로 바로 `0`을 반환하면 된다.

```cpp
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) {
            return 0;
        }

        int ans = 0, left = 0, curr = 1;
        for (int right = 0; right < nums.size(); right++) {
            curr *= nums[right];
            while (curr >= k) {
                curr /= nums[left];
                left++;
            }
            
            ans += right - left + 1;
        }
        
        return ans;
    }
};
```

각 루프 반복에서 수행되는 작업이 일정하게 분산되므로, 이 알고리즘의 실행 시간은 $$O(n)$$이고, 여기서 $$n$$은 `nums`의 길이다. 그리고 이 알고리즘은 $$O(1)$$ 공간을 사용한다.

---

## **고정 윈도우 크기**

앞서 살펴본 예제에서는 윈도우 크기가 변화했다. 윈도우를 특정 제약 조건 내에서 최대한 오른쪽으로 확장하려고 시도하고, 제약 조건을 위반하면 왼쪽에서 요소를 제거했다. 그런데 때로는 문제에서 윈도우의 길이를 **고정된** 길이 `k`로 지정하기도 한다.

이런 문제는 한 윈도우에서 다음 윈도우로 넘어갈 때 변경되는 요소가 오른쪽 하나와 왼쪽 하나뿐이므로 상대적으로 간단하다.

첫 번째 윈도우(인덱스 `0`부터 `k - 1`까지)를 만들어보자. 크기 `k`인 윈도우가 만들어지면, 인덱스 `i`에 요소를 추가하면서 인덱스 `i - k` 요소는 빼야 한다. 예를 들어, `k = 2`일 때 지금 `[0, 1]` 위치에 요소가 있으면, `2`를 추가하면 `[0, 1, 2]`가 된다. 그럼 윈도우 크기를 `k = 2`로 유지하려면 `2 - k = 0` 위치의 요소를 빼서 `[1, 2]`가 되게 해야 한다.

다음은 의사 코드이다:

```cpp
function fn(arr, k):
    curr = some data to track the window

    // build the first window
    for (int i = 0; i < k; i++)
        Do something with curr or other variables to build first window

    ans = answer variable, probably equal to curr here depending on the problem
    for (int i = k; i < arr.length; i++)
        Add arr[i] to window
        Remove arr[i - k] from window
        Update ans

    return ans
```

---

> **예제 4**. 정수 배열 `num`와 정수 `k`가 주어졌을 때, 길이가 `k`인 부분 배열 중 가장 큰 합을 가진 부분 배열의 합을 구하라.
{: .prompt-general }

앞서 언급했듯이 길이 `k`의 윈도우를 만든 다음 배열을 따라 슬라이드하면 된다. 한 번에 한 요소씩 추가하고 제거하여 윈도우가 `k` 크기를 유지하도록 한다. `i`에 값을 추가하는 경우 `i - k`에서 값을 제거해야 한다.

첫 번째 윈도우를 만든 후에는 첫 번째 윈도우의 합계를 고려하기 위해 `curr`로 답을 초기화한다.

```cpp
int findBestSubarray(vector<int>& nums, int k) {
    int curr = 0;
    for (int i = 0; i < k; i++) {
        curr += nums[i];
    }
    
    int ans = curr;
    for (int i = k; i < nums.size(); i++) {
        curr += nums[i] - nums[i - k];
        ans = max(ans, curr);
    }
    
    return ans;
}
```

루프 반복의 총 회수는 $$n$$과 같으며, 여기서 $$n$$은 `nums`의 길이다. 각 반복에서 수행되는 작업은 일정하므로 이 알고리즘의 시간 복잡도는 $$O(n)$$이며, $$O(1)$$의 공간을 사용한다.

---

## **마무리**

슬라이딩 윈도우는 매우 일반적이고 다양한 패턴으로 활용된다. 많은 슬라이딩 윈도우 문제에서 해시맵을 사용해야 하기 때문에 여기서는 기본적인 부분만 다루었다. 해시맵에 대해 배운 다음에는 슬라이딩 윈도우 문제를 몇 가지 더 살펴볼 것이다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/)
