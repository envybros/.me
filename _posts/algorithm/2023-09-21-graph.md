---
title: "그래프 (Graph)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-21 02:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

이진 트리에 대한 이해를 바탕으로 이제 그래프에 대해 알아볼 것이다. 그래프는 노드와 노드 간의 연결로 이루어진 집합이다.

> 노드의 또 다른 용어는 정점이며, 노드 간의 연결을 간선(edge)이라고 한다.
{: .prompt-general }

이진 트리는 그래프의 일종이며 특정한 제약 조건을 가지고 있다. 가장 중요한 제약은 각 노드가 하나의 부모와 최대 두 명의 자식을 가질 수 있다는 것이다. 이러한 제약을 제거하면 그래프는 더 다양한 형태를 가질 수 있다.

그래프는 우리 일상 생활의 일부이다. 말 그대로 무엇이든 그래프로 모델링할 수 있다. 실제 적용 사례로는 페이스북, 트위터, 인스타그램, 틱톡과 같은 소셜 네트워크, 도시의 도로, 회로 기판, 인터넷 네트워크 트래픽, 암호화폐 블록체인, 생물학 모델 등이 있다.

---

## **그래프 용어**

자세히 알아보기 전에 먼저 몇 가지 그래프 용어에 익숙해져야 한다.

노드의 간선은 **방향성**을 **가질 수도** 있고 **가지지 않을 수도** 있다. 방향성을 가진 간선은 한 방향으로만 이동할 수 있음을 의미한다. 예를 들어, 노드 `A`에서 노드 `B`로 향하는 방향성 간선이 있으면, `A`에서 `B`로만 이동할 수 있으며, `B`에서 `A`로는 이동할 수 없다. 그래픽 표현에서 방향성 간선은 노드 사이의 화살표로 나타낸다. 방향성이 없는 간선은 양방향으로 이동할 수 있음을 의미하며, 이 경우 `A`와 `B` 사이를 자유롭게 이동할 수 있다. 그래픽 표현에서 이러한 간선은 노드 사이의 선으로 나타난다.

> 이진 트리에서는 모든 간선이 방향성을 가지며, 이는 이진 트리가 **방향성 그래프**의 한 종류라는 것을 의미한다. 각 노드는 부모 노드로부터 시작하여 자식 노드로만 이동할 수 있으며, 일단 자식 노드로 이동하면 부모 노드로 돌아갈 수 없다.
{: .prompt-general }

또 다른 중요한 용어는 **연결 요소**이다. 그래프 내의 연결 요소는 서로 연결된 노드의 그룹이다. 연결 요소는 그래프 내의 하나 이상의 부분으로 나눌 수 있는 노드의 집합이다.

> 이진 트리에서는 **연결 요소**가 하나만 있어야 한다(루트에서 모든 노드에 도달 가능).
{: .prompt-general }

노드는 여러 개의 간선을 가질 수 있다. 방향성 그래프에서 노드는 들어오는 간선과 나가는 간선을 모두 가질 수 있다. 노드에 연결된 간선의 수를 노드의 **차수(indegree)**라고 하며, 들어오는 간선은 **내부 차수**, 나가는 간선은 **외부 차수**로 분류한다. 간선에 의해 직접 연결된 다른 노드를 **이웃**이라고 한다. 따라서 `A <-> B <-> C`와 같은 그래프가 있다면 `A`는 `B`의 이웃이고, `B`는 `A`와 `C`의 이웃이며, `C`는 `B`의 이웃이다.

> 이진 트리에서, 루트를 제외한 모든 노드는 하나의 부모 노드를 가지므로 내부 차수는 항상 1이다. 노드는 0, 1, 또는 2의 외부 차수를 가질 수 있으며, 외부 차수가 0인 노드를 단말 노드 혹은 리프 노드라고 한다.
{: .prompt-general }

그래프는 순환 구조를 가질 수도 있고 그렇지 않을 수도 있다. 순환 구조를 가진 그래프는 그래프 내에서 하나 이상의 노드를 반복하여 방문하는 경로가 존재함을 의미한다. 이진 트리는 순환 구조를 가지지 않는다는 점에서 비순환적이다.

> 이진 트리는 정의상 주기(Cycle)를 가질 수 없다.
{: .prompt-general }

---

## **알고리즘 문제에서의 그래프가 주어지는 방식**

링크드 리스트 문제에서는 링크드 리스트의 `head`가 주어진다. 이진 트리 문제에서는 트리의 `root`가 주어진다. 그래프 문제에서는 그래프에 대한 정보만 주어진다. 이 정보는 여러 가지 형식으로 제공될 수 있다. 몇 가지를 살펴보겠다.

> 이해해야 할 중요한 점은 링크드 리스트와 이진 트리를 사용하면 데이터와 포인터가 포함된 객체가 메모리에 바로 제공된다는 것이다. 하지만 그래프에서는 그래프 자체가 실제로 메모리에 존재하지 않는다.
>
> 실제로 그래프의 "개념"만 존재하며, 입력은 그래프에 대한 일부 정보를 제공한다. 그래프를 코드로 표현하고 탐색하는 방법을 찾는 것은 우리의 몫이다.
>
> 대부분의 경우 그래프의 노드는 `0`에서 `n-1`까지의 번호가 지정된다. 문제에서 입력이 그래프라고 명시적으로 언급되어 있을 수도 있고, 그렇지 않을 수도 있다. 가끔 스토리가 포함되어 있어서 사용자가 입력이 그래프를 의미하는지 파악해야 할 수도 있다. 예를 들어, "`0`에서 `n - 1`까지 번호가 매겨진 `n`개의 도시가 있다"라고 할 수 있다. 각 도시는 노드로 간주될 수 있으며, 각 도시는 고유한 번호가 있다.
{: .prompt-general }

이진 트리를 사용할 때는 특정 노드에서 `node.left`와 `node.right`로 이동할 수 있기 때문에 탐색이 상대적으로 간단하다. 그러므로 우리는 탐색 방법(DFS 또는 BFS)에 집중할 수 있다. 그러나 그래프에서는 노드가 여러 개의 인접 노드를 가질 수 있다. 일반적으로 탐색을 시작하기 전에 사용자는 특정 `node`의 모든 인접 `node`에 즉시 액세스할 수 있는지 확인하는 몇 가지 작업을 수행해야 한다.

이를 좀 더 구체적으로 설명하기 위해 예를 들어보겠다.

### 첫 번째 입력 형식: 간선 배열

이 형식에서 입력은 2차원 배열로 제공된다. 배열의 각 요소는 `[x, y]` 형태로, `x`와 `y` 사이에 간선이 있음을 나타낸다. 문제 상황에 따라 이러한 간선이 특정 스토리를 나타낼 수 있다. 도시의 예를 들어, "`[x, y]`는 도시 `x`와 도시 `y`를 연결하는 도로가 있음을 의미한다"라고 설명할 수 있다.

> 간선은 방향성을 가질 수도 있고 가지지 않을 수도 있다. 이 정보는 문제 설명에서 확인할 수 있다.
{: .prompt-general }

그렇다면 왜 바로 탐색을 시작할 수 없을까? 예를 들어, 노드 `0`에서 DFS를 시작하고자 한다고 가정해보자(시작 노드가 문제에 지정되어 있거나 사용자가 결정해야 할 수도 있다). 노드 `0`에 있을 때, 인접한 노드를 어떻게 찾을 수 있을까? `0`을 포함하는 모든 간선을 찾으려면 입력 배열을 처음부터 끝까지 검사해야 한다. 인접 노드로 이동하면 그 노드의 모든 인접 노드를 찾기 위해 입력 배열을 처음부터 다시 검사해야 한다.

**모든 노드에서 이웃을 찾기 위해 입력 배열을 반복하는 것**은 매우 비효율적이다!

따라서 탐색을 시작하기 전에, 입력 데이터를 사전 처리하여 특정 노드의 모든 인접 노드를 쉽게 찾을 수 있도록 해야 한다. 이상적으로는, 특정 노드를 인수로 받아 그 노드의 인접 노드 리스트를 반환하는 데이터 구조를 갖추는 것이 좋다. 이를 위한 가장 간단한 방법은 해시 맵을 사용하는 것이다.

정수 키를 정수 리스트에 매핑하는 해시 맵이 있고, 이를 `graph`로 간주한다고 생각해보자. 입력 배열을 반복 처리하면서 각 `[x, y]` 쌍에 대해 리스트 `graph[x]`에 `y`를 추가할 수 있다. 간선이 무방향인 경우, 리스트 `graph[y]`에 `x`도 추가해야 한다. 이 해시 맵을 만든 후, `graph[0]`에 쿼리를 실행하면 노드 `0`과 연결된 모든 노드를 즉시 얻을 수 있다.

> 페이스북에 접속해서 모든 친구 목록을 보고 싶다고 상상해 보자. 그러나 Facebook 엔지니어들은 그래프를 간선 배열의 형태로 유지하기로 결정했다! **전 세계의 모든 연결** (수조 개는 아니더라도 수천억 개에 달할 것이다)을 살펴보고 나와 관련된 연결을 찾아야 한다. 그러나 `graph`가 미리 구축되어 있다면 프로필에서 친구 탭을 클릭하기만 하면 내 친구만 쉽게 확인할 수 있다.
{: .prompt-general }

![Graph](graph.png)

이 예제 그래프는 방향이 지정된 간선의 배열로 나타낼 수 있다: `edges = [[0, 1], [1, 2], [2, 0], [2, 3]]`.

> 이미지의 `graph`는 메모리에 실제로 존재하는 것이 아니다. 이는 [[0, 1], [1, 2], [2, 0], [2, 3]] 배열에서 파생된 추상적인 아이디어일 뿐이다.
{: .prompt-general }

다음은 간선 배열로 `graph`를 작성하는 C++ 예제 코드이다:

```cpp
unordered_map<int, vector<int>> buildGraph(vector<vector<int>>& edges) {
    unordered_map<int, vector<int>> graph;
    for (vector<int>& edge: edges) {
        int x = edge[0], y = edge[1];
        graph[x].push_back(y);
        // graph[y].push_back(x);
        // 위 줄의 주석을 해제하면 무방향 그래프가 된다
    }
    
    return graph;
}
```

---

### 두 번째 입력 형식: 인접 리스트

인접 리스트에서 노드는 `0`에서 `n - 1`까지 번호가 매겨진다. 입력은 2차원 정수 배열이며, 이를 `graph`라고 한다. `graph[i]`는 $$i^{th}$$ 노드에서 나가는 모든 간선의 리스트이다.

위 이미지의 그래프는 인접 리스트로 다음과 같이 나타낼 수 있다: `graph = [[1], [2], [0, 3], []]`.

이 입력으로 이미 특정 `node`의 모든 이웃에 접근할 수 있다. 전처리를 할 필요가 없다! 따라서 인접 리스트는 가장 편리한 형식이다. 예를 들어, 노드 `6`의 모든 이웃을 알고 싶다면 `graph[6]`을 확인하면 된다.

---

### 세 번째 입력 형식: 인접 행렬

다음 형식은 인접 행렬이다. 노드의 번호는 역시 `0`에서 `n - 1`까지이다. `n x n` 크기의 2차원 행렬이 주어지며, 이를 `graph`라고 부른다. `graph[i][j] == 1`이라는 것은 노드 `i`에서 노드 `j`로 나가는 간선이 있다는 것을 의미한다.

![graph2](graph2.png)

이 형식이 주어지면 두 가지 방법이 있다. 순회하는 동안 특정 `node`에서 `graph[node]`를 반복할 수 있고, `graph[node][i] == 1`인 경우 노드 `i`가 이웃임을 알 수 있다. 또는 간선 배열에서 처럼 그래프를 사전 처리할 수 있다. 해시 맵을 생성한 다음 전체 그래프를 반복한다. `graph[i][j] == 1`인 경우, `graph[i]`와 연관된 목록에 `j`를 추가한다. 이렇게 하면 순회를 수행할 때 이웃을 찾기 위해 모든 노드에서 `n`번 반복할 필요가 없다. 이 방법은 노드에 이웃이 몇 개 없고 `n`이 클 때 특히 유용하다.

이 두 접근 방식 모두 시간 복잡도는 $$O(n^2)$$이다.

---

### 마지막 입력 형식: 행렬 (Matrix)

소개할 마지막 형식은 좀 더 복잡하지만 매우 흔한 형식이다. 입력은 2차원 행렬이며, 여기서 문제는 일종의 스토리를 구성한다. 각 셀은 특정 요소를 나타내며, 이 셀들은 어떤 방식으로든 서로 연결될 수 있다. 예를 들어, "행렬의 각 셀은 마을을 나타내며, 각 마을은 상하좌우에 위치한 다른 마을과만 교역한다"와 같은 설정일 수 있다.

이 경우, 행렬의 각 셀 `(row, col)`은 노드를 나타내며, 그 이웃은 `(row - 1, col), (row, col - 1), (row + 1, col), (row, col + 1)` 이 될 것이다(경계 셀의 경우 제외).

---

## **그래프와 트리의 차이점**

그래프 문제와 이진 트리 문제 사이에는 몇 가지 주요 차이점이 있다. 이진 트리에는 탐색을 시작할 `root` 노드가 있지만, 그래프에서는 항상 명확한 "시작" 지점이 있는 것은 아니다.

이진 트리에서는 각 노드에 대한 객체가 주어지며, 각 노드는 자식 노드에 대한 참조를 가지고 있다. 그에 반해 그래프에서는 보통 먼저 입력을 해시 맵 또는 다른 구조로 변환해야 한다. 트리를 탐색할 때, `node.left`와 `node.right`를 참조하여 각 노드를 방문한다. 그러나 그래프를 탐색할 때, 한 노드에 여러 이웃이 있을 수 있으므로, 현재 노드의 모든 이웃을 방문하려면 for 루프를 사용해야 한다.

그래프에 대한 DFS 구현은 트리에 대한 것과 매우 유사하다. 탐색을 종료해야 할 시점을 확인하고, 필요한 모든 이웃을 재귀적으로 방문하며, 필요한 계산을 수행하고, 결과를 반환하는 등의 작업을 포함한다. 필요에 따라 스택을 사용하여 이 과정을 반복적으로 수행할 수도 있다.

방향이 없는 그래프나 사이클이 있는 방향 그래프에서 DFS를 이진 트리와 동일한 방식으로 구현하려고 하면, 무한 루프에 빠질 위험이 있다(예: 링크드 리스트에서의 루프). 트리와 마찬가지로 대부분의 그래프 문제에서는 각 노드를 단 한 번만 방문해야 한다. 따라서 사이클을 방지하고 불필요한 반복 방문을 피하기 위해, 이미 방문한 노드를 체크하기 위한 `seen` 노드를 추적하는 방법이 필요하다. 방문하기 전에 노드가 이미 방문한(`seen`) 상태인지를 확인하고, 만약 그렇지 않다면 방문한 후에 해당 노드를 방문한 상태로 표시한다. 이 방법을 사용하면 각 노드를 상수 시간에 한 번만 방문할 수 있으므로, 전체 프로세스는 효율적으로 이루어진다($$O(1)$$).

> 트리에는 루트에서부터 시작하여 간선들이 "아래" 방향으로만 연결되기 때문에 한 번 노드를 지나고나면 다시 돌아올 수 없다. 그러나 그래프를 사용하면 `A <-> B`와 같은 양방향 관계를 형성할 수 있으며, `A`와 `B` 사이를 계속해서 왕복할 수 있다.
{: .prompt-general }

어느 노드에서 탐색을 시작할지는 문제의 성격과 해결해야 할 과제에 따라 달라진다. 앞으로 이에 대한 다양한 예시를 살펴볼 예정이다. 이 문서는 참고 자료로서 별도로 열어두는 것이 좋다.

> 중요 참고: 파이썬과 같은 언어에서는 집합(set)을 사용하여 이미 방문한(`seen`) 노드를 추적하는 것이 쉽고 빠르다. 그러나 다른 언어에서는 노드의 상태를 미리 알고 있는 경우(대부분의 그래프 문제에서 노드 번호는 `0`부터 `n - 1`까지이므로), 배열을 사용하는 것이 실행 시간(Runtime) 면에서 더 효율적일 수 있다.
{: .prompt-general }

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/707/traversals-trees-graphs/4721/)

<!--

{: .prompt-general }

-->