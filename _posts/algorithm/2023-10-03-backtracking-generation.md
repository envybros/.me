---
title: "[백트래킹] 생성 (Generation)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-31 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

백트래킹으로 해결할 수 있는 문제의 일반적인 유형 중 하나는 모든 가능한 경우를 생성해야 하는 문제다.

---

## **예제 1: 순열**

> [문제 링크](https://leetcode.com/problems/permutations/)
>
> 서로 다른 정수의 배열 `nums`가 주어지면, 가능한 모든 순열을 아무 순서로나 반환하라.
>
> 예를 들어, `nums = [1, 2, 3]`이 주어지면, `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`을 반환한다.
{: .prompt-general }

순열은 중복 없이 `nums`의 모든 요소를 포함한다. 각 순열을 구축하기 위해 현재 만들고 있는

순열이 `curr`인 재귀 함수 `backtrack(curr)`을 사용해보자. 종료 조건은 `curr.length == nums.length`일 때다 - 우리는 순열을 완성했고 더 이상 진행할 수 없다. 종료 조건에서는 `curr`을 정답에 추가하고 반환한다.

모든 순열을 구축하려면 첫 번째 인덱스에 모든 요소가 필요하고, 그 요소들 각각에 대해 두 번째 인덱스에 모든 다른 요소가 필요하다. 따라서, `backtrack` 호출마다 전체 입력을 반복해야 한다. 순열에 중복이 있어서는 안 되므로, `curr`에 숫자를 추가하기 전에 그 숫자가 이미 `curr`에 있는지 확인해야 한다. `backtrack` 호출 각각은 가능성의 트리에서 노드 방문과 같다.

`nums = [1, 2, 3]`을 사용하여, 정답 "트리"는 다음과 같이 생겼다:

![backtracking3](backtracking3.png)

리프 노드는 종료 조건이나 문제의 답이다.

### [예제 1] 상세 설명

먼저, 모든 순열을 생성하기 위해서는 첫 번째 위치에 모든 숫자를 넣어야 한다. 첫 번째 위치에 있는 각 숫자에 대해, 두 번째 위치에 모든 다른 숫자를 시도해야 하고, 알고리즘은 이런 방식으로 계속된다. 우리는 하위 트리를 사용하여 백트래킹을 모델링할 것이다. 트리의 모든 노드는 함수 호출을 나타낸다. 주어진 함수 호출에 대해, 인수 `curr`는 우리가 현재 구축 중인 순열을 나타낸다.

`curr`에 요소를 추가할 때마다, 다른 `backtrack` 호출을 한다. 이것은 하위 노드로 이동하는 것과 동일하다. 루트 노드는 빈 배열을 나타내며, 루트에서 주어진 노드까지의 경로는 `curr`를 나타낸다. 이 트리를 생성/탐색하기 위해, `curr = []`를 사용하여 `backtrack`을 호출한다. 그런 다음 첫 번째 숫자를 첫 번째 위치에 놓고 다시 `backtrack`을 호출한다.

두 번째 호출에서 첫 번째 숫자를 두 번째 위치에 놓을 수 없다. 왜냐하면 우리는 이미 첫 번째 숫자를 사용했기 때문이다. 그래서 대신 두 번째 숫자를 넣고 다시 `backtrack`을 호출한다. 결국, `curr`는 `nums`와 동일한 길이를 갖게 될 것이며, 이것은 모든 숫자를 사용했다는 것을 나타낸다(중복은 허용되지 않기 때문에) 그리고 우리는 유효한 순열을 가지게 된다.

이것은 리프 노드/종료 조건이다 - 우리는 `curr`를 답에 추가하고, 그런 다음 리턴한다. 우리가 리턴할 때마다, DFS와 정확히 같은 방식으로, 우리는 트리를 다시 올라간다. 기억해라: 루트에서 주어진 노드까지의 경로는 `curr`를 나타낸다. 리턴할 때, 우리는 경로의 마지막 노드를 제거한다. 이것은 또한 `curr`에서 마지막 요소를 제거해야 한다는 것을 의미한다.

첫 번째 숫자가 첫 번째 위치에 있을 때 모든 가능성을 시도한 후, 우리는 첫 번째 위치에 두 번째 숫자를 시도하고 다시 하위 트리를 거쳐간다. 일반적으로, `backtrack`을 호출할 때마다, 우리는 입력을 반복하고 `curr`에 없는 번호를 찾으면 그것을 `curr`에 추가하고 하위 트리를 거친다.

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> curr = {};
        backtrack(curr, ans, nums);
        return ans;
    }
    
    void backtrack(vector<int>& curr, vector<vector<int>>& ans, vector<int>& nums) {
        if (curr.size() == nums.size()) {
            ans.push_back(curr);
            return;
        }
        
        for (int num: nums) {
            if (find(curr.begin(), curr.end(), num) == curr.end()) {
                curr.push_back(num);
                backtrack(curr, ans, nums);
                curr.pop_back();
            }
        }
    }
};
```

> 정답을 추가할 때 `curr`의 복사본을 만들어야 한다. `curr`는 배열 주소에 대한 참조일 뿐이기 때문이다.
{: .prompt-general }

이 알고리즘의 시간 복잡도는 매우 느리다. 하지만, 입력값이 1 <= nums.length <= 6으로 제한되어 있기 때문에 이 정도 속도는 예상범위 내이다. `n = nums.length`라고 하자. 트리의 "루트"인 첫 번째 `backtrack` 호출은 `n`번의 호출을 만든다. 그 호출들 각각이 중복을 피하면서 `n - 1`번의 호출을 만들고, 그것들 각각이 `n - 2`번을 만들고, 이런 식으로 계속된다. 알고리즘의 정확한 시간 복잡도는 사실 매우 복잡하지만, 방금 언급한 논리를 사용하여 대략 $$O(n \cdot n!)$$ 정도로 추정할 수 있다. 여기에 각 순열을 복사해야 하기 때문에 `n`이라는 추가 요소가 있다. 공간 복잡도는 `curr`와 재귀 호출 스택에 대해 $$O(n)$$이다.

---

## **예제 2: 부분 집합**

> [문제 링크](https://leetcode.com/problems/subsets/)
>
> 고유 요소의 정수 배열 `nums`가 주어지면 중복 없이 모든 부분 집합을 아무 순서로 반환해보자.
>
> 예를 들어, `nums = [1, 2, 3]`이 주어지면 `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`을 반환한다.
{: .prompt-general }

이 예제는 이전 것과 비슷하다. 하지만 두 가지 주요 차이점이 있다:

- 길이: 부분 집합은 임의의 길이를 가질 수 있지만, 순열은 고정된 길이 `n`을 가진다.
- 요소의 순서: `[1, 2, 3]`과 `[3, 2, 1]`은 서로 다른 순열이지만, 같은 부분 집합이다.

예제 솔루션에서 모든 답이 정렬되어 있다는 것에 주목한다. `nums[i]`에 대한 모든 번호는 `i` 인덱스 이후에만 나타난다. 모든 부분 집합을 찾으면서 중복을 피하기 위해, 우리는 반복을 시작할 위치를 나타내는 정수 `i`를 우리의 `backtrack` 함수에 전달할 수 있다. 입력에 대한 루프를 실행할 때, `[0, n)` 대신 `[i, n)`을 루프한다. `backtrack` 호출 시, 우리가 추가하는 숫자의 인덱스에 1을 더해 전달해서 우리가 추가하는 숫자 이후에 오는 숫자만 하위 트리의 나머지에 포함되도록 할 수 있다.

> 이것은 백트래킹 문제에서 중복을 피하는 매우 일반적인 방법이다 - 각 함수 호출에서 반복의 시작 지점을 나타내는 정수 인수를 가지고 있다.
{: .prompt-general }

### [예제 2] 상세 설명

이전 방식과 동일한 과정을 사용하여 백트래킹 트리를 생성할 수 있다. 이해해야 할 첫 번째 중요한 것은 인수 `i`가 무엇을 나타내는지이다. 이전 문제에서는 각 노드에서 전체 입력을 반복했다. 여기서 그렇게 할 수는 없다. 그렇게 하면 중복된 부분 집합이 생기기 때문이다. 예를 들어, `nums = [1, 2, 3]`이라면 어느 시점에서 `curr = [1, 2]`를 가질 것이다. 첫 번째 위치에 `1`이 있는 하위 트리를 마치면 다음에 첫 번째 위치에 `2`를 시도할 것이다. 각 노드에서 모든 숫자를 고려하면 순서가 여기서 중요하지 않기 때문에 `[1, 2]`의 중복인 `curr = [2, 1]`이 될 것이다. 따라서 `curr`에 요소를 추가할 때 하위 트리 전체에 대해 해당 요소 다음에 오는 요소만 고려하려고 한다. 각 노드에서 반복을 시작할 위치를 알려주는 인수 `i`를 사용한다. `j` 인덱스에 요소를 추가하면 다음 호출에 `j + 1`을 전달한다.

이제 `i`가 무엇을 하는지 이해했으니 이 문제와 이전 문제의 구현 차이점에 대해 이야기해보자. 이전 문제에서 답 노드는 leaf nodes였다(leaf nodes는 `curr`가 `n`의 길이를 갖는 것을 나타냈다). 이 문제에서 부분 집합은 임의의 길이를 가질 수 있으므로 모든 노드가 답이다(루트조차도 루트는 빈 부분 집합 `[]`를 나타내기 때문이다). 따라서 각 노드에서 할 첫 번째 일은 `curr`를 답에 추가하는 것이다. 유일한 다른 차이점은 전체 입력을 반복하는 대신 `i`에서 시작하여 입력을 반복한다는 것이다. 위에서 언급했듯이, 이렇게 하면 우리 답에 중복이 없도록 할 수 있다.

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> curr = {};
        backtrack(curr, 0, ans, nums);
        return ans;
    }
    
    void backtrack(vector<int>& curr, int i, vector<vector<int>>& ans, vector<int>& nums) {
        if (i > nums.size()) {
            return;
        }
        
        ans.push_back(curr);
        for (int j = i; j < nums.size(); j++) {
            curr.push_back(nums[j]);
            backtrack(curr, j + 1, ans, nums);
            curr.pop_back();
        }
    }
};
```

이번에는 종료 조건이 `i > nums.length`일 때다 - 사용할 숫자가 더 이상 없을 때를 말한다. `curr`의 수정과 해당 수정의 취소는 동일하게 유지된다.

> 함수가 입력의 길이보다 큰 인수로 호출될 수 없기 때문에 종료 조건이 실제로는 절대 발생하지 않는다는 것을 알 수 있을 것이다. 명확성을 위해 조건을 포함시켰다.
{: .prompt-general }

입력 배열의 길이인 `n`에 대해 $$2^n$$개의 부분 집합이 있다. 각 요소에 대해 가져오거나 가져오지 않을 수 있다. 시간 복잡도의 경우, 알고리즘을 $$2^n$$개의 노드가 있는 트리에 대한 DFS로 생각할 수 있다. 각 노드에서 `curr`의 복사본을 만들기 때문에 시간 복잡도는 $$O(n \cdot 2^n)$$이다. 공간 복잡도는 `curr`와 재귀 호출 스택에 대해 $$O(n)$$이다.

---

## **예제 3: 조합**

> [문제 링크](https://leetcode.com/problems/combinations/)
>
> 이 문제는 두 개의 정수 변수 `n`과 `k`가 주어졌을 때, `[1, n]` 범위 내의 `k`개의 숫자 조합을 모두 찾아내는 것이다.
>
> 예를 들어, `n = 4, k = 2`인 경우, 반환값은 `[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]` 같은 조합들이 될 것이다.
{: .prompt-general }

자세히 살펴보면, 문제는 길이가 `k`인 `[1, n]` 범위의 모든 부분 집합을 요구하고 있다. 우리는 위에서 사용한 정확히 같은 알고리즘을 사용할 수 있으며, `curr`를 정답에 추가하는 시점을 모든 호출에서 종료 조건이 충족될 때로 변경하기만 하면 된다. `1`부터 `n`까지의 숫자로 배열을 만들 수도 있지만, 그렇게 하면 공간이 낭비될 것이다. 그냥 for 루프의 반복 변수를 사용하면 된다.

### [예제 3] 상세 설명

조합에서도 중복은 허용되지 않는다. 예를 들어, `[1, 2]`와 `[2, 1]`은 같은 것으로 간주된다. 이러한 관찰을 통해 길이가 `k`인 모든 부분 집합을 찾아야 함을 추론할 수 있다. 그렇기 때문에, 이전 문제에서 사용한 코드를 복사하여 약간 수정하기만 하면 된다.

첫 번째로, 새로운 종료 조건은 `curr.length = k`이다. 이 경우 이후에 `curr`에 숫자를 더 추가할 필요가 없다. 왜냐하면 더 긴 길이의 조합은 고려하지 않기 때문이다. 첫 번째 예제에서와 마찬가지로, 리프는 종료 조건을 나타내며 정답이 되는 노드도 되기 때문에, 우리는 모든 노드가 아닌 리프에서만 'curr'를 정답에 추가할 것이다.

이전 두 문제에서는 배열을 순회하며 배열의 요소를 추가했다. 이 문제에서는 `[1, n]` 범위의 숫자를 다루고 있다. 이 문제를 해결하는 한 가지 방법은 `[1, 2, ..., n]` 배열을 생성하고 이 배열에 동일한 알고리즘을 적용하는 것이다. 그러나, for 루프의 반복 변수를 사용함으로써 일부 공간을 절약할 수 있다. 우리는 여전히 `i` 인수를 활용한다. 처음에 `i = 1`은 `1`과 그 이후의 모든 숫자를 고려하고 있다는 것을 나타낸다. `i`부터 `n`까지 for 루프 변수 `num`으로 반복한다. 각 `num`에 대해, 그것을 `curr`에 추가하고 다음 `backtrack` 호출에 `num + 1`을 전달한다.

```cpp
class Solution {
public:
    int k;
    int n;
    
    vector<vector<int>> combine(int n, int k) {
        this->k = k;
        this->n = n;
        vector<vector<int>> ans;
        vector<int> curr = {};
        backtrack(curr, 1, ans);
        return ans;
    }
    
    void backtrack(vector<int>& curr, int i, vector<vector<int>>& ans) {
        if (curr.size() == k) {
            ans.push_back(curr);
            return;
        }
        
        for (int num = i; num <= n; num++) {
            curr.push_back(num);
            backtrack(curr, num + 1, ans);
            curr.pop_back();
        }
    }
};
```

이 알고리즘의 시간 복잡도는 도출하기 매우 어렵다. $$O(\frac{k \cdot n!}{(n−k)! \cdot k!})$$이다. 면접에서 정확한 시간 복잡도를 찾지 못해도 이해할 수 있지만, 여전히 최선을 다해야 한다.

좋은 전략은 시간 복잡도의 상한을 찾는 것이다. 첫 번째 호출에서 for 루프는 `n`번 실행된다. 다음 호출은 `n - 1`번 실행될 수 있고, 그 다음은 `n - 2`번 계속해서 이어지며, 이는 $$O(n!)$$로 이어진다. 그러나 최대 깊이는 `k`이므로 팩토리얼의 곱셈은 `1`까지 내려가지 않고 `n - k`까지 내려간다. 따라서 우리의 팩토리얼을 `(n - k)!`로 나누어야 한다.

또한 각 조합을 복사하는 데 $$O(k)$$의 비용이 든다 - 이것은 실제 시간 복잡도의 좋은 근사치인 $$O(\frac{k \cdot n!}{(n−k)!})$$을 제공한다. 생각 과정을 설명한다면, 어떤 면접관도 이런 답변에 만족할 것이다.

공간 복잡도는 `curr`와 재귀 호출 스택에 대해 $$O(k)$$이다.

보다시피, 이 문제들 각각의 아이디어와 코드는 매우 유사하다. 문제를 트리로 모델링하고, 각 노드가 어떤 자식을 가져야 하는지 파악해보면 된다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/711/backtracking/4536/)

<!--

{: .prompt-general }

-->