---
title: "이진 트리-DFS"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-19 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

> 이 글을 시작하기 전에 이진 트리가 무엇이며 코드에서 어떻게 표현되는지 완전히 이해하고 재귀에 대해 확실히 이해했는지 확인하세요.
{: .prompt-general }

이 글에서는 이진 트리를 순회하는 방법에 대해 설명합니다. 트리 순회는 트리의 요소에 접근하는 방법이며, 따라서 트리 문제를 해결하는 데 필수적인 요소입니다.

링크드 리스트 챕터에서 다음 코드를 사용하여 링크드 리스트를 트래버스한 것을 기억하세요:

```cpp
int getSum(ListNode* head) {
    int ans = 0;
    while (head != nullptr) {
        ans += head->val;
        head = head->next;
    }

    return ans;
}
```

위의 코드는 헤드에서 시작하여 각 노드를 방문하여 링크된 목록에 있는 모든 값의 합계를 구합니다.

각 노드마다 코드 실행 중에 head 변수가 노드를 참조하는 순간이 있습니다. .next 속성을 사용하여 트래버스합니다.

이진 트리를 트래버스하는 것도 같은 원리를 따릅니다. 루트에서 시작하여 하위 포인터 .left 및 .right를 사용하여 트래버스합니다. 연결된 목록을 트래버스할 때는 보통 반복적으로 수행합니다. 이진 트리에서는 일반적으로 재귀적으로 수행합니다.

트리 탐색에는 크게 두 가지 유형이 있습니다. 첫 번째는 깊이 우선 검색(DFS)이라고 합니다. 특히 바이너리 트리의 경우 선순서, 내순서, 후순서의 세 가지 방법으로 DFS를 수행할 수 있습니다(어떤 유형을 선택하든 거의 중요하지 않으니 걱정하지 마세요). 다른 주요 탐색 유형은 폭 우선 탐색(BFS)이라고 합니다. 먼저 DFS에 대해 살펴보겠습니다.

---

## **깊이 우선 탐색 (DFS)**

> 노드의 깊이는 루트와의 거리라는 점을 기억하세요.

DFS에서는 다른 방향을 고려하기 전에 트리에서 한 방향으로 최대한 멀리(리프 노드에 도달할 때까지) 트래버스하여 깊이의 우선 순위를 지정합니다. 예를 들어 왼쪽을 우선 순위 방향으로 선택한다고 가정해 보겠습니다. 왼쪽 하위 트리를 완전히 탐색할 때까지 node.left로만 이동합니다. 그런 다음 오른쪽 하위 트리를 탐색합니다.

tree는 실제 나무와 닮았기 때문에 그런 이름이 붙여졌습니다. 이진 트리의 경로는 뿌리에서 자라는 가지로 생각할 수 있습니다. DFS는 한 가지를 선택하여 가능한 한 아래로 내려갑니다. 가지를 완전히 탐색한 후에는 아직 탐색하지 않은 다른 가지를 찾을 때까지 역추적합니다.

브랜치 끝에 도달한 후 트리를 역추적해야 하므로 일반적으로 재귀를 사용하여 DFS를 구현하지만, 스택을 사용하여 반복적으로 수행하기도 합니다. 다음은 모든 노드를 방문하는 재귀 DFS의 간단한 예시입니다:

> dfs(node )를 호출할 때마다 해당 노드를 방문합니다. 코드에서 볼 수 있듯이, 오른쪽 자식을 방문하기 전에 왼쪽 자식을 방문합니다.
{: .prompt-general }

```cpp
void dfs(TreeNode* node) {
    if (node == nullptr) {
        return;
    }
    
    dfs(node->left);
    dfs(node->right);
    return;
}
```

> 트리를 다시 위로 이동하는 방법을 이해하는 데 어려움이 있다면 첫 번째 장의 '재귀 소개' 문서를 참조하세요.
>
> 또한 DFS를 사용하는 동안 자체 버전의 노드에 대한 많은 호출이 동시에 존재한다는 사실에 익숙해져야 합니다.
{: .prompt-general }

좋은 소식은 DFS를 수행하는 구조가 모든 문제에서 매우 유사하다는 점입니다. 다음과 같이 진행됩니다:

1. 기본 케이스를 처리합니다. 일반적으로 빈 트리(노드 = null)가 기본 케이스입니다.
2. 현재 노드에 대해 몇 가지 로직을 수행합니다.
3. 현재 노드의 자식을 재귀적으로 호출합니다.
4. 답변 반환

> 잠시 후에 살펴보겠지만, 2단계와 3단계는 다른 순서로 진행될 수 있습니다.
{: .prompt-general }

이진 트리 문제를 풀 때 가장 중요한 것은 각 함수 호출이 현재 노드에 루팅된 하위 트리가 입력인 것처럼 원래 문제에 대한 답을 풀고 반환한다는 점입니다. 각 호출(2단계)에서 수행되는 로직은 문제에 따라 달라집니다.

DFS에는 세 가지 유형이 있다고 언급했습니다. 세 가지 유형은 각각 2/3단계를 실행하는 순서만 다릅니다.

이제 다음 트리를 기준으로 유형에 대해 살펴보겠습니다:

![Binary Tree3](binary_tree3.png)

### **전위 순회(Preorder traversal)**

전위 순회에서는 자식으로 이동하기 전에 현재 노드에서 로직이 수행됩니다. 트리에 있는 각 노드의 값을 콘솔에 출력하고 싶다고 가정해 보겠습니다. 이 경우 특정 노드에서 현재 노드의 값을 출력한 다음 왼쪽 자식을 재귀적으로 호출한 다음 오른쪽 자식을 재귀적으로 호출합니다.

```cpp
void preorderDfs(TreeNode* node) {
    if (node == nullptr) {
        return;
    }
    
    cout << node->val << endl;
    preorderDfs(node->left);
    preorderDfs(node->right);
    return;
}
```

예제 트리에서 위의 코드를 실행하면 노드가 이 순서대로 출력되는 것을 볼 수 있습니다: 0, 1, 3, 4, 6, 2, 5.

로직(출력)은 각 함수 호출이 시작될 때 즉시 수행되므로 프리오더는 함수 호출이 발생하는 순서와 동일한 순서로 노드를 처리합니다.

### **중위 순회 순회 (Inorder traversal)**

중위 순회에서는 먼저 왼쪽 자식을 재귀적으로 호출한 다음 현재 노드에서 로직(이 경우 출력)을 수행한 다음 오른쪽 자식을 재귀적으로 호출합니다. 즉, 왼쪽 자식에 대한 호출이 논리 수행보다 우선하기 때문에 왼쪽 자식이 없는 노드에 도달할 때까지는 논리를 수행하지 않습니다.

```cpp
void inorderDfs(TreeNode* node) {
    if (node == nullptr) {
        return;
    }

    inorderDfs(node->left);
    cout << node->val << endl;
    inorderDfs(node->right);
    return;
}
```

예제 트리에서 위의 코드를 실행하면 노드가 이 순서대로 출력되는 것을 볼 수 있습니다: 3, 1, 4, 6, 0, 2, 5.

특정 노드의 경우 왼쪽 하위 트리의 모든 값이 출력될 때까지 해당 노드의 값이 출력되지 않고, 오른쪽 하위 트리의 값이 출력될 때까지 해당 노드의 값이 출력되지 않는다는 점에 유의하세요.

### **후위 순회 (Postorder traversal)**

후위 순회에서는 자식을 먼저 재귀적으로 호출한 다음 현재 노드에서 로직을 수행합니다. 즉, 자식 노드를 호출하는 것이 논리 수행보다 우선하기 때문에 리프 노드에 도달할 때까지는 논리가 수행되지 않습니다. 후위 순회에서 루트는 로직이 수행되는 마지막 노드입니다.

```cpp
void postorderDfs(TreeNode* node) {
    if (node == nullptr) {
        return;
    }

    postorderDfs(node->left);
    postorderDfs(node->right);
    cout << node->val << endl;
    return;
}
```

예제 트리에서 위의 코드를 실행하면 노드가 이 순서대로 출력되는 것을 볼 수 있습니다: 3, 6, 4, 1, 5, 2, 0.

특정 노드의 경우 왼쪽 하위 트리의 모든 값이 출력될 때까지 오른쪽 하위 트리의 값은 출력되지 않으며, 그 이후에는 자체 값이 출력되지 않습니다.

```text
각 순회의 이름은 현재 노드의 로직이 수행되는 시점을 설명합니다.

Pre -> before children

In -> in the middle of children

Post -> after children
```

---



---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/707/traversals-trees-graphs/4722/)

<!--

{: .prompt-general }

-->