---
title: "동적 프로그래밍"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-04 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

동적 프로그래밍(DP)은 문제 해결 기법이다. 보통 DP를 사용하는 문제는 DP로만 해결할 수 있다(합리적인 시간 복잡도 내에서). 많은 사람들에게 DP는 가장 두려운 주제 중 하나이다. 솔직히 말해서, DP에 대해서는 큰 오해가 있다. 이는 아마도 다음의 조합 때문일 것이다:

1. DP를 모르면 쉬운 문제라도 DP 문제를 해결하는 것은 거의 불가능하다.
2. DP는 면접에서 흔히 볼 수 있는 질문이 아니며, 일부 회사에서는 이를 금지하기도 하므로 사람들이 이를 배울 동기가 적다.

---

## **DP란 무엇일까?**

간단히 말해서, 동적 프로그래밍은 최적화된 재귀이다. 어떤 재귀 함수가 원래 문제에 대한 답을 반환하고, 함수 호출을 입력으로 처리한다고 가정해보자. 우리는 이 아이디어를 트리 섹션에서 광범위하게 보았다. 예를 들어, `node`를 가져와서 입력이 `node`에 루트된 하위 트리인 것처럼 원래 문제에 대한 답을 반환하는 함수 `dfs`를 정의하기도 했다.

동적 프로그래밍의 아이디어도 정확히 같다. 우리는 보통 `dp`라고 불리는 어떤 재귀 함수를 정의하는데, 이는 인수를 입력으로 처리하는 것처럼 원래 문제에 대한 답을 반환한다.

재귀 함수가 취하는 인수는 **상태**를 나타낸다. 우리가 트리 문제를 살펴보았을 때, 우리의 DFS에서 노드를 한 번 이상 방문하지 않아서, 상태가 반복되지 않았다. DP와의 차이점은 상태가 보통 지수적인 횟수로 반복될 수 있다는 것이다. 계산을 반복하는 것을 피하기 위해, 우리는 **메모이제이션**이라고 불리는 것을 사용한다. 우리가 주어진 상태에 대한 답(반환 값)을 찾으면, 그 값을 캐시에 저장한다(보통 해시 맵에). 그런 다음에, 만약 우리가 똑같은 상태를 다시 보게 되면, 그것을 다시 계산할 필요 없이 캐시된 값을 참조할 수 있다.

> 그래프를 살펴볼 때와 비슷하게, 상태의 범위가 알려져 있으면, 일부 언어에서는 해싱을 사용하는 대신에 배열을 사용하여 값을 캐시하는 것이 훨씬 나을 수 있다.
{: .prompt-general }

[피보나치 수](https://en.wikipedia.org/wiki/Fibonacci_number)를 예로 들어보자. $$0$$번째 피보나치 수는 `0`이고, 다음 수는 `1`이며, 그 다음 각 수는 이전 두 수의 합이다. $$n$$번째 피보나치 수에 대한 공식은 $$F_n$$ = $$F_{n-1}$$ + $$F_{n-2}$$이다. 우리는 $$n$$번째 피보나치 수를 찾는 함수를 작성할 수 있다:
{: .prompt-general }

> 공식 $$F_n$$ = $$F_{n-1}$$ + $$F_{n-2}$$는 재귀 관계라고 한다.
{: .prompt-general }

```cpp
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    }
    
    if (n == 1) {
        return 1;
    }
    
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

이 알고리즘은 시간 복잡도가 $$O(2^n)$$이다. 이는 `fibonacci`를 호출할 때마다 두 개의 추가적인 `fibonacci` 호출을 생성하기 때문이다. 여기에 `fibonacci(6)`에 대한 재귀 트리가 있다:

![Dp](dp.png)

보다시피, 반복된 계산이 많이 있다 - 예를 들어, `f(4)`는 두 번 계산되고, `f(3)`은 세 번 계산되며, `f(2)`는 다섯 번 계산된다. 이 정도 크기에서는 큰 문제처럼 보이지 않는다. 그러나 `n`이 커짐에 따라, 반복 계산은 기하급수적으로 증가한다. 만약 우리가 `f(7)`을 계산하고 싶다면, 이 전체 트리는 루트의 한쪽이 될 것이다.

계산을 반복하는 것을 피하기 위해, 우리는 함수 호출로부터의 결과를 **메모이제이션**할 수 있다. 해시 맵을 사용하여 결과를 저장하고 재귀 호출을 하기 전에 해시 맵을 확인해보자.

```cpp
unordered_map<int, int> memo;

int fibonacci(int n) {
    if (n == 0) {
        return 0;
    }
    
    if (n == 1) {
        return 1;
    }
    
    if (memo.find(n) != memo.end()) {
        return memo[n];
    }
    
    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return memo[n];
}
```

이것은 우리의 시간 복잡도를 $$O(n)$$으로 개선한다 - 물론, $$O(2^n)$$에 비해 극도로 빠르다. 첫 번째 접근법은 기본 재귀에 불과하다 - 중복 계산을 피하기 위해 결과를 메모이제이션함으로써, 이것은 **동적 프로그래밍**이 된다.

---

## **하향식(Top-down) vs 상향식(Botton-up)**

재귀와 메모이제이션을 사용하는 이 방법은 또한 "하향식" 동적 프로그래밍으로도 알려져 있다. 이는 우리가 위쪽(원래의 문제)에서 시작하여 종료 조건 방향으로 아래로 이동하기 때문에 이렇게 명명된다. 예를 들어, 우리는 n번째 피보나치 수를 원했기 때문에 `fibonacci(n)`을 호출하여 시작했다. 우리는 종료 조건(`F(0)`과 `F(1)`)에 도달할 때까지 재귀를 통해 아래로 이동한다.

동적 프로그래밍 문제를 접근하는 또 다른 방법은 "상향식" 알고리즘을 사용하는 것이다. 상향식에서는 아래쪽(종료 조건)에서 시작하여 더 큰 문제로 올라간다. 이것은 반복적으로 수행되며 **타뷸레이션**으로도 알려져 있다. 여기에 피보나치의 상향식 버전이 있다:

```cpp
int fibonacci(int n) {
    vector<int> arr(n + 1);
    // 종료 조건 - the second Fibonacci number is 1
    arr[1] = 1;
    for (int i = 2; i <= n; i++) {
        arr[i] = arr[i - 1] + arr[i - 2];
    }
    
    return arr[n];
}
```

상향식과 하향식은 알고리즘을 어떻게 구현할지에 대한 것일 뿐이다. 기본적으로 두 접근 방식 사이에 차이는 없다. 모든 하향식 구현은 상향식으로, 그 반대도 마찬가지로 구현할 수 있다. DP 알고리즘을 정의하는 것은 종료 조건와 재귀 관계다(다음 글에서 더 자세히 다룰 예정이다).

두 방식 모두 장단점이 있지만, 각각의 주요 논점은 다음과 같다:

- 보통 상향식 구현이 더 빠르다. 이는 반복이 재귀보다 오버헤드가 적기 때문이지만, 사용하는 언어가 [꼬리 재귀](https://en.wikipedia.org/wiki/Tail_call)를 구현하는 경우에는 이것이 덜 영향을 미친다.
- 그러나 하향식 접근법은 보통 구현하기가 더 쉽다. 재귀를 사용하면, 상태를 방문하는 순서가 중요하지 않다. 반복을 사용할 때, 여러 차원의 문제가 있으면, for 루프의 올바른 구성을 파악하는 것이 어려울 때가 있다.

---

## **DP를 사용해야 하는 시기**

DP로 해결해야 할 문제들은 주로 두 가지 주요 특성을 가지고 있다:

1. 문제는 무언가의 최적 값(최대 또는 최소) 또는 어떤 것을 하는 방법의 수를 요구할 것이다.
    - ...을 하는 최소 비용은 무엇인가?
    - ...의 최대 이익은 무엇인가?
    - ...을 하는 방법은 몇 가지인가?
    - 가능한 가장 긴 것은 무엇인가?
2. 각 단계에서 "결정"을 내려야 하며, 결정들이 미래의 결정에 영향을 미친다.
    - 결정은 두 요소 사이를 선택하는 것일 수 있다
    - 미래의 결정에 영향을 미치는 결정은 "요소 `x`를 택하면 미래에 요소 `y`를 택할 수 없다"와 같은 것일 수 있다

첫 번째 특성에 대한 참고 사항: 이러한 형식의 모든 문제가 DP로 해결되어야 하는 것은 아니며, 모든 DP 문제가 이러한 형식 중 하나에 속하는 것은 아니다. 그러나 일반적인 지침으로, 이러한 특성들은 매우 잘 적용된다.

> 두 번째 특성을 명확히 하기 위해, [House Robber](https://leetcode.com/problems/house-robber/)라는 클래식한 DP 문제를 살펴보자.
>
> 거리를 따라 있는 집들을 털 계획을 하고 있다. $$i$$번째 집에는 `nums[i]`의 돈이 있다. 만약 서로 인접한 두 집을 털면, 경보 시스템이 작동하고 경찰에게 알릴 것이다. 경찰을 경보하지 않고 털 수 있는 가장 많은 돈은 얼마인가?
{: .prompt-general }

두 번째 특성은 보통 탐욕스럽고 DP를 구분한다. 탐욕스러운 생각은 지역적 결정이 다른 결정에 영향을 미치지 않는다는 것이다. `nums = [2,7,9,3,1]`가 있다고 해보자, 그리고 우리는 탐욕스러워야 한다. 배열을 따라 반복하면, 첫 번째 결정은 `2`나 `7`을 가져가는 것이다, 우리는 둘 다 가질 수 없기 때문이다. 탐욕스러우면, `7`을 가져간다. 그러나 이제 `9`를 더 이상 가져갈 수 없다. 실제로, 최적의 답은 `2, 9, 1`을 취하는 것이다. 보다시피, 우리의 결정에 탐욕스러워하면 미래의 결정에 영향을 미쳐 잘못된 답으로 이끌 수 있다.

---

## **상태**

이전 장에서 간략하게 상태에 대해 언급했다. 상태는 시나리오를 완벽하게 설명할 수 있는 변수 집합을 의미한다. 트리 문제를 살펴볼 때, 모든 재귀 호출 `dfs`는 `node`를 인수로 받았고, 어쩌면 다른 변수들도 인수로 받았을 것이다. 이 인수들은 상태를 나타낸다. 다음 글에서 DP 알고리즘을 만드는 첫 번째 단계는 필요한 상태 변수를 결정하는 것임을 알게 될 것이다.

트리에 대해 이야기할 때, `dfs`에 대한 각 함수 호출이 호출에 전달된 상태가 입력인 것처럼 원래 문제에 대한 답을 반환할 것이라고 말했다. DP에서도 마찬가지다. `dp(state)`에 대한 호출은 `state`가 입력인 것처럼 원래 문제의 답을 반환해야 한다.

다음은 생각해야 할 일반적인 상태 변수들이다:

- 입력 문자열, 배열 또는 숫자를 따라 인덱스. 이것은 가장 일반적인 상태 변수이며 거의 모든 문제에서 상태 변수가 될 것이며, 종종 유일한 상태 변수가 될 것이다. 피보나치에서 "인덱스"는 현재 피보나치 숫자를 가리킨다. 배열이나 문자열을 다루고 있다면, 이 변수는 이 인덱스까지 포함하여 배열/문자열을 나타낼 것이다. 예를 들어, `nums = [0, 1, 2, 3, 4]`가 있고 상태 변수 `i = 2`가 있다면, 마치 `nums = [0, 1, 2]`가 입력인 것처럼 될 것이다.
- 입력 문자열이나 배열을 따라 두 번째 인덱스. 때로는 배열의 오른쪽 경계를 나타내기 위해 또 다른 인덱스 변수가 필요할 수 있다. 또한, `nums = [0, 1, 2, 3, 4]`가 있고 입력을 따라 두 상태 변수가 있다고 해보자, `i = 1`이고 `j = 3`이라고 하자, 그러면 마치 `nums = [1, 2, 3]`인 것처럼 될 것이다 - 우리는 `i`와 `j` 사이 및 포함하는 입력만 고려하고 있다.
- 문제에서 명시적으로 주어진 수치 제약조건. 이것은 보통 `k`로 입력으로 주어진다. 예를 들어, "`k`개의 장애물을 제거할 수 있다"라고 한다. 이 상태 변수는 우리가 제거할 수 있는 장애물이 얼마나 더 남아 있는지를 나타낸다.
- 상태를 설명하는 부울 값. 예를 들어, "현재 패키지를 보유하고 있으면 참, 그렇지 않다면 거짓".

사용된 상태 변수의 수는 알고리즘의 차원성이다. 예를 들어, 알고리즘이 `i`와 같은 변수 하나만 사용한다면, 그것은 일차원적이다. 문제에 여러 상태 변수가 있으면, 그것은 다차원적이다. 어떤 문제들은 최대 [다섯 차원](https://leetcode.com/problems/maximize-grid-happiness/)까지 요구할 수 있다.

---

## **DP 알고리즘의 시간 및 공간 복잡도**

DP 알고리즘에 대한 복잡도 분석은 매우 쉽다. 트리/그래프와 마찬가지로, 우리는 각 상태를 한 번만 계산한다. 따라서, 가능한 상태가 $$N$$개 있고, 각 상태에서 수행되는 작업이 $$F$$라면, 시간 복잡도는 $$O(N \cdot F)$$가 될 것이다. 이것은 우리가 트리와 그래프 문제에서 사용한 정확히 동일한 논리이다.

공간 복잡도는 $$O(N)$$이 될 것이다 - 상향식을 사용하고 있다면, 우리의 해시 맵은 마지막에 모든 상태를 저장할 것이다. 하향식을 사용하고 있다면, 탭을 위해 사용하는 배열은 상태 수와 동일한 크기가 될 것이다.

> 많은 문제에서, 공간 복잡도는 하향식을 구현할 때는 개선되지 않지만, 상향식을 구현할 때는 개선될 수 있다. 이것은 장의 나머지 부분에서 볼 것이다.
{: .prompt-general }

상태 수 $$N$$을 계산하기 위해, 각 상태 변수를 살펴보고, 그들이 취할 수 있는 값의 범위를 계산한 다음, 그들을 함께 곱한다. 세 개의 상태 변수가 필요한 어떤 문제가 있다고 해보자: `i`, `k`, 그리고 `holding`. `i`는 입력 `nums`를 반복하고, `k`는 문제에서 주어졌고, `holding`은 불리언이다. 그러면 상태 수는 `nums.length * k * 2`가 된다. 각 상태를 계산하는 것이 $$O(1)$$이라면, 시간 및 공간 복잡도는 $$O(n \cdot k)$$가 될 것이다, 여기서 `n = nums.length`.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/712/dynamic-programming/4539/)

<!--

{: .prompt-general }

-->