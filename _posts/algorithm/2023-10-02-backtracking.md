---
title: "백트래킹 (Backtracking)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-02 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

문제를 해결하는 가장 비효율적인 방법은 **완전 탐색**을 통한 것이다. 가능한 모든 경우의 수를 생성한 다음 각각을 확인하여 해결책을 찾는다.

`a-z`의 글자를 가지고 있고, 이 글자들을 사용하여 길이가 `n`인 문자열을 생성하라고 요청받았다고 가정해보자. 가능한 경우의 수는 $$26^n$$이며, `n`개의 글자 각각이 `a-z`가 될 수 있다. 모든 가능성을 트리로 상상할 수 있다. 루트는 빈 문자열 `""`이고, 그 다음 모든 노드에는 26개의 자식이 있으며, 루트에서의 경로가 구축 중인 문자열을 나타낸다. 따라서 루트에서 시작하여 `"g"` 노드로 간 다음, 그 노드에서 `"p"` 노드로 간다면, 이것은 문자열 `"gp"`를 나타낸다. 트리의 깊이는 `n`이고, 리프 노드는 정답을 나타낸다.

![backtracking](backtracking.png)

이제 길이가 `n`인 **모든** 해결책 대신 제약 조건을 만족하는 해결책만 원한다고 가정하자. 완전 탐색은 여전히 길이가 `n`인 **모든** 문자열을 "후보"로 생성한 다음 각각을 제약 조건에 대해 확인한다. 이것은 `k`가 문자열이 제약 조건을 충족하는지 확인하는 데 드는 비용인 경우, 시간 복잡도가 $$O(k * 26^n)$$이 되며, 이 시간 복잡도는 매우 느리다.

**백트래킹**은 경로가 해결책으로 이어질 수 없다고 판단되면 "경로"를 포기하는 최적화 기법이다. 이 아이디어는 이진 탐색 트리와 유사하다 - 만약 값 `x`를 찾고 있다면, 그리고 루트 노드의 값이 `x`보다 크다면, 오른쪽 하위 트리 전체를 무시할 수 있다는 것을 알고 있다. 각 하위 트리의 노드 수가 깊이에 대해 지수 함수적이기 때문에, 백트래킹은 엄청난 양의 계산을 절약할 수 있다. 문자열이 모음만 가질 수 있다는 제약 조건이 있었다면, 완전 탐색은 여전히 $$26^n$$개의 문자열을 모두 생성한 다음, 각각이 모음만 있는지 확인한다. 되돌아가기를 사용하면, 자음을 포함한 모든 하위 트리를 버려서, 후보를 $$O(26^n)$$에서 $$O(5^n)$$으로 개선한다.

![backtracking2](backtracking2.png)

> 경로를 포기하는 것은 "가지치기"라고도 한다.
>
> 완전 탐색과 백트래킹의 차이를 요약하면 다음과 같다:
>
> 완전 탐색에서는 모든 가능성을 생성한 다음 해결책을 찾기 위해 확인한다. 반면, 백트래킹에서는 해결책으로 이어질 수 없는 경로를 가지치기함으로써 훨씬 적은 수의 가능성을 생성한다.
{: .prompt-general }

백트래킹은 문제가 무언가를 모두 찾으라고 할 때나, **모든** 논리적 가능성을 확인하지 않고서는 해결책을 찾을 명확한 방법이 없을 때 훌륭한 도구가 된다. 코딩 연습 사이트에서 백트래킹을 사용해야 한다는 강력한 힌트는 입력 제약이 매우 작은 경우(`n <= ~15`)로, 백트래킹 알고리즘은 보통 지수 시간 복잡도를 가진다.

불행히도 코딩 테스트에서는 보통 제약 조건이 명시되지 않으며, 면접관에게 명확히 하려고 해도 그들은 모호한 대답을 하거나 최선을 다하라고만 말할 것이다. 이것이 특정 알고리즘을 사용할 때를 인식하기 위한 좋은 직관을 구축하는 것이 중요한 이유다.

---

## **구현**

백트래킹은 거의 항상 재귀로 구현된다 - 반복적으로 수행하는 것은 정말 의미가 없다. 대부분의 백트래킹 문제에서는 무언가를 구축할 것이다. 이는 직접적으로(배열 수정 등)이나 간접적으로(어떤 상태를 나타내는 변수 사용) 일어난다. 다음은 일반적인 백트래킹 형식을 위한 의사코드이다:

```text
/ curr가 당신이 구축하고 있는 것을 나타내게 하자
// 이것은 배열일 수도 있고, 변수의 조합일 수도 있다

function backtrack(curr) {
    if (base case) {
        정답 증가시키기 또는 추가하기
        return
    }

    for (입력을 순회) {
        curr 수정하기
        backtrack(curr)
        curr에 했던 수정을 취소하기
    }
}
```

가능성이 트리에 의해 표현된다는 비유를 다시 생각해보자.

`backtrack` 함수에 대한 각 호출은 트리의 노드를 나타낸다. for 루프의 각 반복은 현재 노드의 자식을 나타내며, 그 루프에서 `backtrack`을 호출하는 것은 자식으로 이동하는 것을 나타낸다.

수정을 취소하는 줄은 "백트래킹" 단계로, 자식에서 부모로 트리를 다시 올라가는 것과 동일하다.

주어진 노드에서, 루트에서 노드까지의 경로는 구축 중인 후보를 나타낸다. 리프 노드는 완전한 해결책이며, 기본 케이스에 도달할 때를 나타낸다. 이 트리의 루트는 빈 후보자이며, 원래의 `backtrack` 호출이 이루어지는 범위를 나타낸다.

이 장에서는 문제에 대해 생각하는 매우 직관적인 방법이기 때문에 트리를 사용하여 백트래킹 프로세스를 나타낼 것이다.

> 이 트리 비유가 혼란스럽다면 걱정하지 말자. 다가오는 예제 문제들의 비디오 설명에서 이 개념을 훨씬 명확하게 이해할 수 있을 것이다.
{: .prompt-general }

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/711/backtracking/4535/)

<!--

{: .prompt-general }

-->