---
title: "투 포인터 (Two pointer)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-07 01:20
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

투 포인터는 배열과 문자열 문제를 푸는 데 사용되는 매우 일반적인 기법이다. 여기에는 반복자(Iterable)를 따라 이동하는 두 개의 정수 변수를 활용한다. 이 글에서는 배열과 문자열에 초점을 맞춰 설명할 것이다. 투 포인터에서는 `i`와 `j` 또는 `left`와 `right`라는 이름을 갖는 두 변수를 사용한다.

투 포인터를 활용하는 방법에는 여러 가지가 있다. 먼저 다음 방법을 살펴보도록 하자:

> 입력의 양 끝에서 포인터를 시작한다. 포인터가 서로 만날 때까지 서로를 향해 중앙으로 이동한다.
{: .prompt-general }

이 방식에 따라, 명령어는 다음과 같이 나타낼 수 있다:

1. 한 포인터는 첫 번째 인덱스 `0`에서 시작하고, 다른 포인터는 마지막 인덱스 `input.length - 1`에서 시작한다.
2. 포인터가 서로 같아질 때까지 while 루프를 반복한다.
3. 반복하는 동안, 포인터의 위치에 따라 어느 포인터를 움직일지 결정한다. 여기서 포인터를 이동하는 방식은 해결하려는 문제의 특성에 따라 달라진다(왼쪽만, 또는 오른쪽만, 아니면 둘 다).

다음은 해당 개념을 설명하는 의사 코드이다:

```cpp
function fn(arr):
    left = 0
    right = arr.length - 1

    while left < right:
        // 문제에 따라 특정 로직을 수행
        // 어느 포인터를 이동할지 결정하는 로직을 수행:
            1. left++
            2. right--
            3. Both left++ and right--
```

이 기법의 강점은 포인터가 서로 $$n$$만큼 떨어져서 시작하고 모든 반복에서 적어도 한 단계 더 가까이 이동하기 때문에 while 루프에 대해 $$O(n)$$ 이상의 반복이 발생하지 않는다는 것이다. 따라서 각 반복 내의 연산을 $$O(1)$$로 유지할 수 있다면, 이 기법을 사용했을 때 선형 런타임이 발생하게 된다. 이는 가능한 최상의 런타임이 될 것이다. 몇 가지 예시를 살펴보자.

---

> 예제 1: 문자열 `s`가 주어졌을 때, 이것이 회문(palindrome)이면 `true`를 반환하고, 아니면 `false`를 반환한다.
>
> 여기서 회문은 앞뒤가 동일한 문자열을 의미한다. 예를 들면 "abcdcba", "racecar"가 있다.
{: .prompt-general }

문자열을 뒤집으면 첫 번째 문자가 마지막 문자가 된다. 만약 문자열이 정상적인 회문이라면, 뒤집은 문자열과 원본 문자열이 동일해야 한다. 여기서 투 포인터 기법을 사용하면 해당하는 모든 문자가 동일한지 확인할 수 있다. 먼저 두 개의 개별 포인터를 사용하여 첫 번째와 마지막 문자를 확인한다. 다음 문자 쌍을 확인하기 위해서는 포인터를 서로 하나씩 이동하면 된다. 포인터가 서로 만나거나, 일치하지 않는 지점을 찾을 때까지 계속 진행한다.

> `n`은 총 문자 수이므로 `n - i - 1`은 마지막, 마지막에서 두 번째, 마지막에서 세 번째 등의 문자에 해당한다. 입력이 0부터 시작하는 인덱스이므로, `-1`이 필요하다.
{: .prompt-general }

```cpp
bool checkIfPalindrome(string s) {
    int left = 0;
    int right = s.size() - 1;
    
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}
```

입력이 문자열이 아닌 문자 배열인 경우, 알고리즘의 변화는 없다는 점에 유의해야 한다. 투 포인터 기법은 인덱스 변수가 추상적인 반복자(Iterable)을 따라 이동하며 작동한다.

이 알고리즘은 $$O(n)$$에서 작동하며, $$O(1)$$ 공간만을 사용하기 때문에 매우 효율적이다. 그리고 입력의 크기와 관계없이 항상 두 개의 정수 변수만을 사용한다. 시간 복잡도가 $$O(n)$$인 이유는 while 루프의 각 반복이 $$O(1)$$의 비용을 요구하고, 두 포인터가 최대 $$n$$만큼 떨어진 거리에서 시작하여 서로 가까워지며 이동하기 때문이다.

---

> 예제 2: 주어진 고유한 **정렬된** 정수 배열과 목표 정수를 기반으로 합산되는 숫자 쌍이 있으면 `true`를 반환하고, 그렇지 않으면 `false`를 반환한다. 이 문제는 [Two Sum](https://leetcode.com/problems/two-sum/)과 유사하다. (주의: Two Sum 문제에서는 입력이 정렬되지 있지 않다).
>
> 예를 들어 `nums = [1, 2, 4, 6, 8, 9, 14, 15]`, `target = 13`이 주어지면, `4 + 9 = 13`이므로 true를 반환한다.
{: .prompt-general }

무차별 대입 (Bruce force) 솔루션은 모든 정수 쌍을 검사하는 것이다. 배열의 각 숫자는 다른 숫자와 조합될 수 있기 때문에, 시간 복잡도는 $$O(n^2)$$이 되며, 여기서 $$n$$는 배열의 길이이다. 주어진 배열이 이미 정렬되어 있기 때문에, 투 포인터를 활용해 시간 복잡도를 $$O(n)$$으로 줄일 수 있다.

우선 예제 입력을 확인해보자. 투 포인터를 사용하여 초기에 첫 번째 숫자와 마지막 숫자를 확인할 수 있다. 이들의 합은 `1 + 15 = 16`인데, `16 > target`이므로 현재 합계를 줄여야 한다. 따라서 `right` 포인터를 이동시킨다. 이제 `1 + 14 = 15`가 되었다. 이번에도 합이 너무 크므로 right 포인터를 이동시킨다. 이제 `1 + 9 = 10`이 되었다. 이번에는 합이 너무 작기 때문에 더 크게 만들어주기 위해 `left` 포인터를 이동시킨다. `2 + 9 = 11 < target`이므로 다시 이동시킨다. 마지막으로 `4 + 9 = 13 = target`이 되어 목표값과 일치해졌다.

이 알고리즘이 작동하는 이유는 숫자가 정렬되어 있기 때문이다. 우리가 left 포인터를 이동하면 left 포인터가 가리키는 값이 증가한다 (`nums[left] = x`). 마찬가지로 right 포인터를 이동시키면 오른쪽 포인터가 가리키는 값이 감소한다(`nums[right] = y`). `x + y > target`인 경우, `x`만으로는 증가만 가능하므로 해를 구할 수 없다. 따라서 해가 존재한다면 `y`를 줄여야만 해를 찾을 수 있다. 반대로 `x + y < target`인 경우에는 동일한 논리를 `x`에 적용할 수 있다.

```cpp
bool checkForTarget(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        // curr <- 현재 합계
        int curr = nums[left] + nums[right];
        if (curr == target) {
            return true;
        }
        if (curr > target) {
            right--;
        } else {
            left++;
        }
    }

    return false;
}
```

이전 예제에서와 마찬가지로 이 알고리즘은 $$O(1)$$ 공간을 사용하며, 시간 복잡도는 $$O(n)$$이다.

---

## **다른 접근 방식**

첫 번째와 마지막 인덱스에서 포인터를 시작하여 서로를 향해 이동하는 이 방법은 투 포인터 전략 중 한나일 뿐이다. "투 포인터"는 단지 아이디어일 뿐이며, 다양한 방식으로 구현될 수 있다. 투 포인터는 아래의 입력에 두 개의 반복자가 있는 문제(예: 두 개의 배열)에도 적용할 수 있다.

> 두 입력을 모두 검사할 때까지 동시에 이동한다.
{: .prompt-general }

이 개념을 단계별로 나누면 다음과 같다:

1. 각 반복자마다 하나씩, 총 두 개의 포인터를 생성한다. 두 포인터는 모두 첫 번째 인덱스에서 시작한다.
2. 한 포인터가 해당 반복자의 끝에 도달할 때까지 while 루프를 실행한다.
3. 루프 내에서 포인터를 한 단계씩 앞으로 이동시킨다. 어떤 포인터를 이동시킬지는 문제의 종류에 따라 달라진다.
4. 한 포인터가 끝에 도달하면, 다른 포인터가 그 반복자의 끝에 도달하지 않았다면 추가로 처리해야 할 경우가 있을 수 있다.

다음은 이 개념을 설명하는 의사 코드이다:

```cpp
function fn(arr1, arr2):
    i = j = 0
    while i < arr1.length AND j < arr2.length:
            // 문제에 따라 여기에서 몇 가지 논리를 수행하자
            // 여기에서 논리를 더 수행하여 다음 중 하나를 결정한다:
            1. i++
            2. j++
            3. Both i++ and j++

    // 4단계: 두 반복자가 모두 소진되었는지 확인한다.
    // 이 루프 중 하나만 실행된다는 점에 유의하자.
    while i < arr1.length:
        // 문제에 따라 여기에서 몇 가지 논리를 수행하자
        i++

    while j < arr2.length:
        // 문제에 따라 여기에서 몇 가지 논리를 수행하자
        j++
```

첫 번째 방법과 유사하게, 이 방법은 while 루프 내부의 작업이 $$O(1)$$일 때 선형 시간 복잡도가 $$O(n + m)$$이며, 여기서 `n = arr1.length`, `m = arr2.length`이다. 이는 모든 반복마다 적어도 하나의 포인터가 앞으로 이동하며, 배열이 소진되지 전까지 포인터가 `n + m`회 이상 앞으로 이동할 수 없기 때문이다. 몇 가지 예를 살펴보자.

---

> 예제 3: 정렬된 정수 배열 `arr1`과 `arr2`가 주어졌을 때, 두 배열을 합친 후 정렬된 새 배열을 반환한다.
{: .prompt-general }

가장 간단한 접근 방법은 먼저 두 입력 배열을 합친 다음 정렬하는 것이다. `n = arr1.length + arr2.length`인 경우, 시간 복잡도는 $$O(n \cdot \log{}n)$$(정렬 비용)이다. 입력 배열이 정렬되지 않았다면 이는 좋은 접근 방식이겠지만, 이미 정렬되어 있다면, 투 포인터 기법을 활용하여 $$O(n)$$로 개선할 수 있다.

> 이 예제 앞의 설명에서 `n = arr1.length`, `m = arr2.length`라고 선언했다. 그런데 여기서는 `n = arr1.length + arr2.length`라고 한다. 왜일까? 빅오의 경우, 변수를 원하는 대로 정의할 수 있다는 점을 기억해보자. 이 경우 정렬 접근법의 시간 복잡도는 $$O((n + m) \cdot \log{}(m + n))$$가 되고, 우리가 다루려는 접근법의 시간 복잡도는 $$O(n + m)$$가 될 것이다. 실제로 차이가 크지 않지만, 배열을 합칠 때 총 길이가 길어질 수 있으므로, 이를 `n`으로 표현하는 것이 합리적이라는 점을 근거로 들 수 있다.
{: .prompt-general }

우리는 한 번에 하나의 요소만으로 `답(ans)` 배열을 생성할 수 있다. 각 배열의 첫 번째 인덱스에서 투 포인터를 시작하고 그 요소를 비교한다. 각 반복마다 두 값 중 작은 값을 결과에 추가하고 해당 포인터를 이동한다.

```cpp
vector<int> combine(vector<int>& arr1, vector<int>& arr2) {
    // ans is the answer
    vector<int> ans;
    int i = 0, j = 0;
    while (i < arr1.size() && j < arr2.size()) {
        if (arr1[i] < arr2[j]) {
            ans.push_back(arr1[i]);
            i++;
        } else {
            ans.push_back(arr2[j]);
            j++;
        }
    }
    
    while (i < arr1.size()) {
        ans.push_back(arr1[i]);
        i++;
    }
    
    while (j < arr2.size()) {
        ans.push_back(arr2[j]);
        j++;
    }
    
    return ans;
}
```

앞서 소개한 두 예와 마찬가지로 이 알고리즘의 시간 복잡도는 $$O(n)$$이며, $$O(1)$$의 공간만 사용한다(출력을 여분의 공간으로 계산하지 않다면. 일반적으로는 계산하지 않는다).

---

> 예제 4: [부분 수열 (subsequence) 여부 판별](https://leetcode.com/problems/is-subsequence/)
>
> 두 문자열 `s`와 `t`가 주어졌을 때, `s`가 `t`의 부분 수열이면 `true`를, 아니면 `false`를 반환한다.
>
> 부분 수열이란 원 문자열에서 몇몇 문자를 삭제하여 얻을 수 있는 문자열로, 남은 문자들의 순서는 그대로 유지된다. 예시로, "ace"는 "abcdef"의 부분 수열이나, "aec"는 아니다.
{: .prompt-general }

이 문제에서는 `s`의 문자들이 `t` 내에서 동일한 순서로 나타나는지를 확인한다 (연속성의 여부는 여기선 중요하지 않다). 즉, `"abcde"`에는 `"ace"`가 동일한 순서로 포함되어 있기 때문에, `"ace"`는 `"abcde"`의 부분 수열이다.

투 포인터 기법을 활용하면 이 문제를 선형 시간 안에 해결할 수 있다. 만약 `s[i] == t[j]`라면, `s`의 `i`번째 문자를 찾았다는 것을 의미하고, `i`를 증가시켜 다음 문자를 확인한다. 각 반복에서 `j`는 항상 증가된다. 만일 `s`의 모든 문자를 찾게 되면, `s`는 `t`의 부분 수열라는 것을 의미하며, 이는 `i == s.length`일 때 확인할 수 있다.

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < s.size() && j < t.size()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        
        return i == s.size();
    }
};
```

이 솔루션은 $$O(1)$$ 공간만 사용하며, 시간 복잡도는 `s`와 `t`의 길이에 따라 선형이다.

---

## **마무리**

첫 번째 방법에서는 포인터를 첫 번째와 마지막 인덱스에서 시작했으나, 때로는 다른 인덱스에서 시작할 필요가 있을 수 있다. 두 번째 방법에서는 두 개의 다른 입력 배열을 따라서 두 포인터를 이동시켰다. 때로는 입력이 하나의 배열 또는 문자열일 때도 첫 번째 인덱스에서 두 포인터를 초기화하고, 둘 다 이동시킬 필요가 있다.

투 포인터는 두 개의 정수 변수를 이용하여 반복자를 순회하는 것을 의미한다. 이 글에서는 가장 흔하게 사용되는 패턴을 다루었지만, 문제에 따라 다양한 방식으로 접근할 필요가 있다. "쓰리 포인터"를 활용하는 문제도 존재한다.

> 투 포인터 기법은 이 글에서 소개한 것 이상으로 많은 문제 해결 전략에 사용될 수 있다.
{: .prompt-general }

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4501/)
