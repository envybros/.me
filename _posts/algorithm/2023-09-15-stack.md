---
title: "스택 (Stack)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-15 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

스택은 한쪽 끝에서만 요소가 추가되고 제거되는 정렬된 요소 모음이다. 물리적 세계에서 스택의 예로는 부엌의 접시 더미를 들 수 있다. 접시를 추가하거나 더미 맨 위에서 접시를 제거할 수 있다. 소프트웨어 세계에서는 스택의 좋은 예로 현재 브라우저 탭의 기록을 들 수 있다. `A` 사이트에 있다가 링크를 클릭하여 `B` 사이트로 이동하고, `B`에서 또 다른 링크를 클릭하여 `C` 사이트로 이동한다고 가정해 보자. 링크를 클릭할 때마다 스택에 추가되는 것이므로 이제 기록은 `[A, B, C]`가 된다. 뒤로 가기 버튼을 클릭하면 가장 최근의 방문 기록이 스택에서 "제거"된다. 한 번 클릭하면 `[A, B]`가 되고, 다시 클릭하면 `[A]`가 된다.

> 스택을 설명하는 데 사용되는 또 다른 용어는 **LIFO**(마지막으로 들어온 것이 처음으로 나가는 방식)이다. 이는 스택에 가장 최근에 추가된 요소가 가장 먼저 제거된다는 것을 의미한다.
{: .prompt-general }

스택은 구현하기가 매우 간단하다. [Java](https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html)와 같은 일부 언어에는 스택 클래스가 내장되어 있다. Python에서는 리스트 `stack = []`을 사용하고, `stack.append(element)`로 요소를 추가하고, `stack.pop()`으로 요소를 제거하면 된다. 사실, 동적 배열을 사용하는 어떤 데이터 구조도 스택으로 사용될 수 있다. 스택에 요소를 추가하는 것을 **push**라고 하고, 제거하는 것을 **pop**이라고 한다. 스택은 보통 **peek** 연산도 제공하는데, 이는 스택의 맨 위에 있는 요소를 반환하지만 제거하지는 않는 것을 의미한다.

스택 연산의 시간 복잡도은 구현에 따라 다르다. 동적 배열을 사용하는 경우, 연산의 시간 복잡도은 일반적으로 $$O(1)$$로 푸시, 팝, 그리고 맨 위의 요소에 대한 접근이 가능하다. 하지만 요소를 찾는 것은 $$O(n)$$의 시간이 걸린다. 스택은 링크드 리스트로도 구현될 수 있으며, 이 경우 일반적으로 모든 연산이 $$O(1)$$의 시간 복잡도을 가진다.

> "스택"이라는 개념의 핵심은 한쪽 끝에서만 요소를 추가하고 제거할 수 있다는 것이다. 이는 구현 방법에 관계없이 일관되는 특징이다. "스택"은 이러한 특성을 가진 추상적인 인터페이스 또는 개념이다.
>
> 스택과 재귀 호출은 밀접한 관련이 있다. 재귀 호출은 스택을 사용하여 함수 호출을 관리한다. 새로운 함수 호출이 있을 때마다 이 호출 정보가 스택에 푸시된다. 현재 "활성화된" 호출은 스택의 맨 위에 위치한다. 함수가 반환값을 반환하거나 실행을 완료하면, 해당 호출은 스택에서 pop된다.
{: .prompt-general }

알고리즘 문제를 해결할 때, 스택은 후입선출(LIFO) 패턴을 이용할 수 있는 상황에서 유용하다. 이러한 문제는 보통 요소들 사이의 상호 작용을 포함한다. 상호 작용은 요소들을 매칭시키거나, "다음으로 큰 요소는 얼마나 큰가"와 같은 질의를 하는 것, 주어진 문자열 형식의 수학 방정식을 평가하는 것, 요소들을 비교하는 것 등을 포함할 수 있다. 때로는 LIFO 특성을 인식하기 어려운 경우도 있으며, 이러한 경우를 감지하는 방법에 대해서도 이야기할 것이다.

---

## **인터페이스 가이드**

다음은 C++로 작성된 스택 인터페이스에 대한 간단한 가이드이다:

```cpp
// 선언: C++은 여러 구현을 지원하지만 
// 여기서는 std::stack을 사용할 것이다. 데이터 타입을 명시해야 한다.
stack<int> stack;

// 요소 푸시:
stack.push(1);
stack.push(2);
stack.push(3);

// 요소 팝:
// 다른 언어들과는 달리, 여기서 팝 작업은 팝된 값을 반환하지 않는다.
stack.pop();
stack.pop();

// 스택이 비어 있는지 확인
stack.empty(); // false

// 맨 위의 요소 확인
stack.top(); // 1

// 스택 크기 얻기
stack.size(); // 1
```

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/706/stacks-and-queues/4514/)
