---
title: "배열(Array)과 문자열(string)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-06 00:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

알고리즘 문제에서 일차원 배열과 문자열은 둘 다 정렬된 요소 그룹을 나타낸다는 점에서 꽤 유사하다고 할 수 있다. 대부분의 알고리즘 문제에는 배열 또는 문자열이 입력의 일부로 포함되므로 우선 기본 연산에 익숙해지고 가장 일반적인 패턴을 익히는 것이 중요하다.

"배열(Array)"은 언어마다 다른 의미를 가질 수 있다. 예를 들어 파이썬은 배열 대신 주로 "리스트(List)"를 사용하는데, 이는 매우 관대하다. 초기화는 `arr = []`처럼 간단하며, 리스트에 저장하는 데이터 유형이나 리스트의 크기에 대해 걱정할 필요도 없다. C++와 같은 언어에서는 초기화 단계에서 배열의 크기와 데이터 유형을 지정해야 한다. 그래도 리스트를 지원한다. (예: C++의 `std::vector`)

> 기술적으로 배열은 크기를 조정할 수 없다. 동적 배열, 즉 리스트는 가능하다. 알고리즘 문제의 맥락에서 사람들이 배열에 대해 이야기할 때 대체로 동적 배열을 가리킨다. **앞으로 이 블로그에 동적 배열/리스트에 대해 이야기할 것이지만, 이번 챕터에서는 그냥 "배열"이라는 단어를 사용할 것이다.**
{: .prompt-general }

마찬가지로 문자열은 언어마다 다르게 구현된다. 파이썬과 자바에서는 문자열이 불변(immutable)이다. 단, C++에서는 변경이 가능하다. 코딩 테스트에서 사용하려는 언어의 배열과 문자열에 대해 자세히 알아두는 것은 매우 중요하다. 여기서 각 언어의 다양한 구현을 모두 살펴볼 시간은 없으므로, 필요하다면 각자 조사해보도록 하자.

> 가변(mutable): 변경할 수 있는 데이터 유형
>
> 불변(immutable): 변경할 수 없는 데이터 유형
>
> 불변 변수를 변경하기 위해서는 전체를 처음부터 다시 만들어야 한다.
{: .prompt-general }

우리가 가변인지, 불변인지 왜 신경써야 할까? 가변 배열 `arr = ["a", "b", "c"]`와 불변 문자열 `s = "abc"`가 있다. 여기서 `"abd"`로 내용을 바꾸고 싶다고 가정해보자. `arr[2] = "d"`는 쉽게 진행할 수 있지만, `s[2] = "d"`는 할 수 없다. 따라서 문자열 `s = "abd"`를 원한다면 완전히 처음부터 새로 만들어야 한다. 이렇게 작은 문자열에는 큰 문제가 되지 않는다. 하지만 100,000개의 문자가 있는 문자열을 처리해야 할 때도 있는데, 이 때 문자 하나를 수정하기 위해 매번 새 버전을 생성하는 것은 매우 비싼 코스트를 소모하게 될 것이다. $$O(n)$$, 여기서 $$n$$은 문자열의 크기.

앞서 언급했듯, 대부분의 알고리즘 문제는 배열이나 문자열과 관련이 있다. 배열과 문자열은 매우 다재다능한 데이터 구조이므로, 관련 문제 해결 기법을 이 곳에 전부 나열하는 것은 불가능에 가까운 일이다. 다음 몇 개의 글에서 가장 일반적인 기법들을 알아볼 것이다. 우선 배열과 문자열 연산의 복잡도에 대해 간단히 확인해보자.

| 연산 (Operation)             | 배열/리스트  | 문자열(불변)     |
|-----------------------------|--------------|-----------------|
| 끝에 추가 (Appending)        | $O(1)$      | $O(n)$           |
| 끝에서 빼기 (Popping)         | $O(1)$     | $O(n)$          |
| 끝이 아닌 곳에 삽입 (Insertion)| $O(n)$     | $O(n)$          |
| 끝이 아닌 곳에서 삭제 (Deletion)| $O(n)$    | $O(n)$          |
| 요소 수정 (Modifying)        | $O(1)$     | $O(n)$          |
| 임의의 위치 접근              | $O(1)$     | $O(1)$          |
| 요소 존재 여부 확인 (exists)  | $O(n)$     | $O(n)$          |

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4500/)
