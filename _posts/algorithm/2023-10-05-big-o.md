---
title: "빅오(Big O)에 대하여"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-10-05 00:10
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## 개요

빅오(Big O)는 알고리즘의 계산 복잡도를 설명하는 데 사용되는 표기법이다. 여기서 계산 복잡도는 시간 복잡도와 공간 복잡도 두 부분으로 나뉜다.

- 시간 복잡도: 입력 크기를 기준으로 알고리즘을 실행해야 하는 시간
- 계산 복잡도: 입력 크기를 기준으로 알고리즘에 의해 할당되는 메모리의 양

> 대부분의 사람들이 공간 복잡도보다 시간 복잡도에 더 신경쓰지만, 사실은 둘 다 알아야 한다.
{: .prompt-general }

---

## 복잡도의 작동 방식

복잡도는 **함수**로 설명할 수 있다. 이 함수(Big O)에 대한 인수의 범위는 얼마나 되어야 할까?

기본적으로 인수는 프로그래머가 정의하지만, 인수에 대한 입력이 변경될 때 변경될 수도 있는 관련 변수들 또한 모두 포함해야 한다. 우리가 가장 일반적으로 쓰는 변수는 다음과 같다. $$n$$ <- 대체로 배열의 길이를 나타낸다.

코딩 테스트 환경에서는 고려해야 할 몇가지 내용이 있다. 예를 들면, **정수**를 다룰 때 값이 크면 클수록 *더하기*, *곱하기*, 또는 *출력*과 같은 연산은 더 많은 시간이 소요된다. 이론적으로 맞는 말이지만, 실제로는 그 차이가 매우 작기 때문에, 이 사실은 대체로 무시된다. 정수의 배열이 입력으로 주어지면, 배열의 길이를 나타내는 유일한 변수는 $$n$$ 하나 뿐이다. 물론 우리는 기술적으로 다른 변수를 도입할 수도 있다. $$k$$를 사용하여 배열에 있는 정수의 평균값을 나타낼 수도 있다. 하지만 아무도 그렇게 하지는 않는다.

우리가 함수로 표기할 때는 대문자 $$O$$로 묶는다. 다음은 복잡도의 예시이다:

- $$O(n)$$
- $$O(n^2)$$
- $$O(2^n)
- $$O(logn)$$
- $$O(n·m)$$

> 여기서 $$m$$은 특별할 것 없이 그저 변수를 정의한 것이다. 예를 들어, "두 개의 배열이 입력으로 들어온다"라고 하는 문제가 있다고 해보자. 여기서 $$n$$은 첫번째 배열의 길이를 표현할 수 있고, 또 $$m$$은 다른 배열의 길이를 표현할 수 할 수 있다.
{: .prompt-general }

---

## 규칙

이 함수(Big O)는 인수가 **극한의 값으로 향함**에 따라 알고리즘에 필요한 연산과 메모리의 양이 어떻게 증가하는지를 설명한다. 여기서 변수는 극한, 즉, 무한대로 향하기 때문에 **상수 값은 항상 무시된다.** 예를 들어:

$$O(9999999n) = O(8n) = O(n) = O(n/500)$$

이다.

> 우리가 주목해야 할 점은 "입력의 크기에 따라 알고리즘이 어떻게 확장되는가"이다. 만약 두 개의 알고리즘이 있다고 가정해보자. 하나는 $$O(100n)$$으로 실행되고, 다른 하나는 $$O(5n)$$으로 실행된다. 여기서 $$n$$의 값을 두 배로 늘리면 두 알고리즘 모두 똑같이 2배 더 오래걸릴 것이다. 따라서 두번째 알고리즘이 20배 더 빠르게 실행된다. 하지만, 두 알고리즘 모두 $$n$$에 따라 선형적으로 증가하기 때문에 두 알고리즘 모두 $$O(n)$$이다.
{: .prompt-general }

이는 **동일한** 변수의 항 사이에 덧셈이나 뺄셈이 있는 경우, 일부 항을 무시할 수 있다는 뜻이 된다. 예를 들어, $$O(2n + n^2 - 500) = O(n^2)$$에서 $$n$$이 극한 값으로 향할수록 $$2^n$$이 다른 두 항을 완전히 지배하기 때문이다.

알고리즘을 분석하고 시간과 공간의 복잡도를 도출할 수 있는 능력은 매우 중요한 기술이다. 당신이 지원할 회사의 면접관들은 당신이 단순히 코드를 외우거나, 복사한 것이 아니라 실제로 알고리즘을 이해하고 있는지 먼저 확인하기 위해 **항상 알고리즘의 복잡도를 물어볼 것**이다. 또한 알고리즘을 분석할 수 있는 능력을 갖춘다면, 알고리즘의 어떤 부분을 개선할 수 있는지 파악할 수 있다.

> 최고의 복잡도는 "상수 시간" 또는 "상수 공간"인 $$O(1)$$이다. 이는 알고리즘이 입력에 관계없이 항상 동일한 양의 리소스를 사용한다는 것을 의미한다.
>
> 그러나 시간 복잡도가 일정하다고 해서 알고리즘이 반드시 빠르다는 의미는 아니다. 그저 알고리즘의 런타임이 입력 크기와 무관하다는 의미일 뿐이라는 점에 유의하자. ($$O(50000000) = O(1)$$)
{: .prompt-general }

복잡도에 대해 이야기할 때는 대체로 다음 세 가지 경우가 있다:

- 최상 케이스 시나리오
- 평균 케이스
- 최악 케이스 시나리오

대부분의 알고리즘에서는 이 세 가지가 모두 동일하다. 하지만 일부 알고리즘에서는 이 세 가지가 전부 제각각일 수도 있다. 만약 당신이 알고리즘의 시간 혹은 공간 복잡도를 나타내기 위해 단 하나의 케이스만 선택해야 한다면 절대로 최상의 시나리오를 선택하면 안된다. 최악의 시나리오를 사용하는 것이 가장 정확하고, 두 경우의 차이점에 대해 이야기할 수 있어야 한다.

---

## 시간 복잡도 분석하기

의사 코드 (pseudo-code)의 몇 가지 알고리즘 예시를 살펴보고, 시간 복잡도에 대해 이야기해보도록 하겠다.

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    print(num)
}
```

이 알고리즘의 시간 복잡도는 $$O(n)$$이다. 각 for 루프의 반복마다 $$O(1)$$의 비용이 드는 출력을 수행한다. 여기서 for 루프는 n번 반복되므로 시간 복잡도는 $$O(1-n) = O(n)$$이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    for (int i = 0; i < 500,000; i++) {
        print(num)
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n)$$이다. 내부 for 루프의 반복에서 $$O(1)$$의 비용이 드는 출력을 수행한다. 그리고 이 for 루프는 500,000번 반복되므로 외부 for 루프 반복에는 $$O(500000) = O(1)$$의 비용이 든다. 여기서 외부 for 루프는 $$n$$번 반복되므로 시간 복잡도는 $$O(n)$$이 된다.

앞의 두 알고리즘은 기술적으로는 시간 복잡도가 동일하지만, 실제로는 두 번째 알고리즘이 첫 번째 알고리즘보다 **훨씬** 더 느리다. 시간 복잡도가 $$O(n)$$이라고 하는 것은 맞는 말이지만, 실용성과 이론의 차이에 대해 설명할 수 있는 것은 매우 중요한 일이다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int num: arr) {
    for (int num2: arr) {
        print(num * num2)
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n^2)$$이다. 내부 for 루프 반복에서 곱셈과 출력을 수행하는데, 둘 다 $$O(1)$$의 비용이 든다. 그리고 내부 for 루프는 $$n$$번 실행되므로 외부 for 루프 반복에는 $$O(n)$$의 비용이 든다. 여기서 외부 for 루프는 $$O(n)$$번 실행되므로 시간 복잡도는 $$O(n⋅n)=O(n^2)$$가 된다.

---

```cpp
// 길이가 n인 정수 배열 "arr"와 길이가 m인 "arr2"가 주어진다.

for (int num: arr) {
    print(num)
}

for (int num: arr) {
    print(num)
}

for (int num: arr2) {
    print(num)
}
```

이 알고리즘의 시간 복잡도는 $$O(n+m)$$이다. 처음 두 개의 for 루프는 모두 $$O(n)$$의 비용이 드는 반면, 마지막 for 루프는 $$O(m)$$의 비용이 든다. 따라서 시간 복잡도는 $$O(2n+m) = O(n+m)$$이 된다.

---

```cpp
// 길이가 n인 정수 배열 "arr"이 주어진다.

for (int i = 0; i < arr.length; i++) {
    for (int j = i; j < arr.length; j++) {
        print(arr[i] + arr[j])
    }
}
```

이 알고리즘의 시간 복잡도는 $$O(n^2)$$이다. 내부 for 루프는 외부 for 루프가 현재 어떤 반복에 있는지에 따라 달라진다. 내부 for 루프가 처음 실행될 때는 n번 실행된다. 그리고 두 번째로 실행하면 $$n-2$$번, 그 다음에는 $$n-2$$번, $$n-3$$번 등의 순서로 실행된다.

즉, 총 반복 횟수는 $$1 + 2 + 3 + 4 + ... + n$$이며, 이 수열의 부분 합은 $$\frac{n \cdot (n+1)}{2} = \frac{n^2 + n}{2}$$. 빅오에서는 분자의 덧셈 항과 분모의 상수 항이 모두 무시되므로, $$O(n^2)$$이 된다.

---

