---
title: "이진 트리 (Binary trees)"
categories: [Algorithm 연구소]
tags: [Algorithm]
date: 2023-09-18 01:30
math: true
img_path: /assets/img/algorithm/
---

---

![Title](algorithm_title.png)

---

## **개요**

> 이 장 전체에서 재귀를 많이 사용한다. 재귀에 익숙하지 않은 경우 계속하기 전에 첫 번째 장의 "재귀" 문서를 검토하길 권한다.
{: .prompt-general }

## **노드 및 그래프**

이 장에서는 **가장 일반적인 유형**의 면접 질문 중 하나인 트리와 그래프에 대해 알아볼 것이다(해시 맵은 실제로 "타입"의 질문이 아니며, "배열"이나 "문자열"처럼 매우 광범위한 범주에 속한다). 트리와 그래프는 물리적 세계와 소프트웨어 세계에서 흔히 볼 수 있는 추상적인 데이터 구조이다. 이 장은 이 강좌에서 가장 긴 부분이지만 그만한 가치가 있다. 많은 면접 문제가 트리나 그래프를 기반으로 하고 있으며, 많은 경우 문제 전체가 트리와 그래프를 중심으로 회전하기 때문이다. 따라서 코딩 면접을 준비하는 사람에게는 트리와 그래프에 대한 충분한 이해가 필수적이다.

먼저, **노드(node)**가 무엇인지 다시 살펴보자. 링크드 리스트 장에서 노드를 다루었듯이, 노드는 두 가지 주요 특성을 가진 추상적인 데이터 유형이다. 첫째, 노드는 데이터를 저장한다. 이 데이터는 정수, 부울, 해시 맵, 사용자 정의 객체 등 무엇이든 될 수 있다. 둘째, 노드는 다른 노드를 가리키는 포인터를 가지고 있다.

**그래프**는 노드와 그 노드들 간의 연결을 나타내는 포인터의 집합이다. 사실, 링크드 리스트와 트리 모두 그래프의 특별한 형태라 할 수 있다. 그래프는 매우 **광범위**한 주제로, [그래프 이론](https://en.wikipedia.org/wiki/Graph_theory)이라는 전체 연구 분야가 존재한다.

트리는 그래프의 한 유형이지만, 알고리즘 문제를 다룰 때는 트리와 그래프를 서로 다른 주제로 취급하는 경우가 많다. 그래프는 보다 복잡하고 고급 주제이므로 우선 트리부터 살펴보도록 하자.

> 그래프의 노드는 **정점(vertices)**이라고도 하며, 노드 간의 연결은 **간선(edges)**이라고 한다. 그래픽 상에서, 노드 또는 정점은 일반적으로 원으로 표시되며, 간선은 이 원들을 연결하는 선 또는 화살표로 표현된다(이전에 링크드 리스트 장에서 본 바와 같다).
{: .prompt-general }

---

## **트리란 무엇일까?**

**트리**는 링크드 리스트와 마찬가지로 그래프의 한 유형이다. 또한 링크드 리스트와 마찬가지로 트리에도 여러 유형이 있다. 이 강좌에서는 이진 트리를 중점적으로 다룰 것이다. **이진 트리**가 무엇인지 살펴보자.

> 링크드 리스트의 시작을 **헤드(head)**라고 불렀던 것을 기억해보자. 이진 트리의 시작을 루트라고 한다.
{: .prompt-general }

링크드 리스트에서 노드의 포인터는 **다음** 노드를 가리킨다. 트리에서 노드는 **자식들**에 대한 포인터를 가진다. 노드 `A`가 노드 `B`를 가리키고 있는 경우, `B`는 `A`의 **자식**이고 `A`는 `B`의 **부모**이다. 루트는 **부모**가 없는 유일한 노드이다. 트리에서 노드는 두 개 이상의 부모를 가질 수 없다.

그렇다면 이진 트리를 "이진"으로 만드는 것은 무엇일까? 이진 트리에서 모든 노드는 **최대** 두 개의 자식을 가진다. 이러한 자식들을 **왼쪽** 자식과 **오른쪽** 자식이라고 한다. 자식이 왼쪽에 있든 오른쪽에 있든 실제로 중요한 차이는 없으며, 단지 자식을 구분하는 데 사용되는 용어일 뿐이다.

요약하자면, 이진 트리는 노드의 집합이다. 모든 노드에는 0개에서 2개의 자식이 있으며, 루트를 제외한 모든 노드에는 정확히 하나의 부모가 있다.

다음은 이진 트리의 예이다:

![binary_tree](binary_tree.png)

> 값이 `3`인 노드가 루트 노드이다. 보다시피, 모든 노드에는 정확히 하나의 부모와 최대 2개의 자식이 있다. `6`은 `5`의 왼쪽 자식이고 `4`는 `2`의 오른쪽 자식이다.
{: .prompt-general }

트리(이진 트리뿐만 아니라)는 실생활 곳곳에서 사용된다. 몇 가지 예를 들어보자:

- 파일 시스템
- Reddit 또는 Twitter와 같은 앱의 댓글 스레드
- 회사의 조직도

이러한 각 예제에서, 각각의 루트 노드와 자식은 다음과 같다:

- 루트 디렉토리 및 하위 폴더/파일
- 원본 게시물/트윗, 댓글 및 답글
- CEO 및 직속 보고자

좀 더 구체적으로 회사의 예를 살펴보자. 회사를 트리로 모델링하면 각 직원은 노드이고, `A`가 `B`를 관리하는 경우 `A`에서 `B`까지 간선이 존재한다. 이 경우 CEO는 회사의 '최상위'에 있고, 다른 직원이 관리하지 않기 때문에 루트가 된다. CEO에게 6명의 직속 보고자(CFO, COO, CTO 등 최고 경영진)가 있다고 가정해 보자. 이는 CEO에게 6명의 '자식'이 있다는 의미이며, 이는 이진 트리가 아니라는 것을 의미한다. 최고 경영진에 속한 각 사람은 부사장처럼 자신에게 보고하는 사람이 있을 것이고, 그 부사장은 이사에게 보고하는 사람이 있을 것이다.

> 트리를 구성하는 회사의 중요한 특징은 각 사람의 상사(상위)가 1명뿐이고, 전체 트리가 연결되어 있다는 점이다(누구든지 자신의 상사를 계속 추적하면 항상 CEO에 도달하게 된다).
{: .prompt-general }

---

## **트리 관련 용어**

트리를 이해하기 위해서는 몇 가지 용어를 익혀야 한다.

**루트** 노드는 트리의 최상위(top)에 있는 노드이다. 트리의 모든 노드는 루트 노드에서부터 시작하여 접근할 수 있다. 대부분의 트리 문제에서는 링크드 리스트의 `head`가 입력으로 주어지는 것처럼 트리의 `root`가 입력으로 주어진다.

노드 `A`가 노드 `B`로 향하는 간선을 가지고 있는 경우(`A -> B`), 노드 `A`를 노드 `B`의 **부모**라고 하고, 노드 `B`를 노드 `A`의 **자식**이라고 한다.

노드에 자식이 없는 경우, 이를 **리프** 노드 혹은 **단말** 노드라고 한다. 리프 노드는 트리의 **잎**이다.

노드의 **깊이**는 루트 노드로부터 해당 노드까지의 거리를 의미한다. 루트 노드의 깊이는 `0`이며, 어떤 노드의 자식 노드는 그 노드의 깊이보다 1만큼 깊이가 더 있다(`parentsDepth + 1`).

트리의 **하위 트리(Subtree)**는 특정 노드와 그 노드의 모든 자손으로 구성된다. 트리는 재귀적 구조를 가지고 있어, 특정 노드를 루트로 하는 하위 트리를 독립적인 트리로 간주할 수 있다. 예를 들어, 회사 구조를 트리로 표현한다면, CEO가 **루트** 노드인 트리가 될 것이다. 만약 엔지니어링 팀만을 고려하는 경우, CTO를 루트 노드로 하는 새로운 트리를 생각할 수 있다. 만약 이 팀을 회사의 다른 부서와 분리한다면(예를 들어, CTO와의 관계를 끊는다면), 엔지니어링 팀만으로 구성된 독립적인 트리가 될 것이다. 이 트리는 이제 회사 전체 구조를 나타내는 것이 아니라 엔지니어링 팀의 구조를 나타낸다. 이러한 방식으로 **특정 노드를 중심으로 한 하위 트리를 갖고 문제**를 재귀적으로 해결할 수 있다.

하위 트리의 개념을 설명하기 위해 다음 이미지를 살펴보자:

![Binary Tree2](binary_tree2.png)

이미지에서 녹색 상자로 둘러싸인 부분은 값이 `1`인 노드를 루트로 하는 하위 트리이다. 이 하위 트리는 값이 `3`인 노드의 오른쪽 하위 트리라고 볼 수 있다. 이 하위 트리는 그 자체로 완전한 이진 트리 구조를 가진다.

---

## **코드로 표현하기**

링크드 리스트와 마찬가지로, 이진 트리도 사용자 정의 클래스의 객체를 사용하여 구현된다. 다음은 알고리즘 문제에서 일반적으로 제공되는 클래스 정의의 예시이다:

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int val) : val(val), left(nullptr), right(nullptr) {}
};
```

이진 트리 문제에서는 보통 이진 트리의 `root` 노드에 대한 참조가 입력으로 제공된다. `root.left`는 루트의 왼쪽 **하위 트리**를, `root.right`는 루트의 오른쪽 **하위 트리**를 참조한다. 링크드 리스트와 유사하게, 각 노드는 데이터를 담고 있는 `val` 값을 가지고 있다. 링크드 리스트에서 마지막 노드는 다음 노드를 가리키는 포인터가 없음을 나타내기 위해 `nullptr`를 사용하듯이, 이진 트리에서도 어떤 노드의 왼쪽 자식 노드가 없으면 `node.left`는 `nullptr`이 되고, 오른쪽 자식이 없는 경우에는 `node.right`가 `nullptr`이 된다. 노드의 양쪽 자식이 모두 없으면, 해당 노드는 **리프** 노드가 된다.

다음 섹션에서는 이진 트리의 탐색 방법과 이와 관련된 문제 해결 방법에 대해 다룰 것이다. 이진 트리 문제는 매우 흔한 유형이므로, 다음 단계로 넘어가기 전에 **이진 트리의 특성과 코드로 어떻게 표현되는지를 완벽하게 이해하는 것**이 중요하다. 그러므로 이 문서를 반복해서 검토하고 내용에 익숙해질 때까지 연습하는 것이 좋다.

---

출처: [Leetcode](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/707/traversals-trees-graphs/4722/)

<!--

{: .prompt-general }

-->