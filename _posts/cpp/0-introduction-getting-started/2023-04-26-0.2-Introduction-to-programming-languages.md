---
title: "0.2 - 프로그래밍 언어 소개"
categories: [C++, Intro]
tags: [c++]
date: 2023-04-26 00:12
---

>[0.2 — Introduction to programming languages](https://www.learncpp.com/cpp-tutorial/introduction-to-programming-languages/){:target="_blank"}
{: .prompt-source }

오늘날의 컴퓨터는 놀라울 정도로 빠르며, 그 속도는 날이 갈수록 점점 더 빨라지고 있습니다. 하지만 컴퓨터는 기본적으로 제한된 명령어만을 이해할 수 있으며, 정확히 무엇을 해야 하는지 알려줘야 한다는 제약 조건이 있습니다.

**컴퓨터 프로그램**(**애플리케이션**이라고도 함)은 컴퓨터가 어떤 작업을 수행하기 위한 일련의 명령어 세트입니다. 이러한 프로그램을 만드는 과정을 **프로그래밍**이라고 합니다. 프로그래머는 보통 하나 이상의 텍스트 파일에 명령어 나열인 **소스 코드**(보통 **코드**로 줄임)를 생성하여 프로그램을 만듭니다.

**하드웨어**란 컴퓨터를 구성하고 프로그램을 실행하는 물리적 장치들의 집합을 의미합니다. 컴퓨터 프로그램이 메모리에 로드되고 하드웨어가 각 명령을 순차적으로 실행하는 것을 **running** 또는 **executing**이라고 합니다.

## 기계어 (Machine Language)

컴퓨터의 CPU는 C++를 처리하지 못합니다. CPU가 직접 이해할 수 있는 제한된 명령어 세트를 **기계 코드**(또는 **기계어** 또는 **명령어 세트**)라고 합니다.

다음은 기계어의 명령어 예제입니다: `10110000 01100001`

처음 컴퓨터가 발명되었을 때 프로그래머들은 기계어로 직접 프로그램을 작성해야 했습니다. 이는 매우 어렵고 시간이 많이 소요되는 작업이었습니다.

위 명령어가 어떻게 구성되는지에 대해서는 다루지 않겠지만, 두 가지 재미있는 사실을 눈여겨볼 필요가 있습니다. 첫째, 각 명령어는 1과 0의 조합으로 구성됩니다. 각각의 0 또는 1을 **이진수(binary digit)** 또는 간단히 **비트(bit)**라고 합니다. 예를 들어 일부 CPU는 항상 32비트 길이의 명령어를 처리하는 반면, 일부 다른 CPU(예: 여러분이 사용 중인 x86 제품군)는 길이가 가변적일 수도 있는 명령어를 가지고 있습니다.

둘째, 각 이진수 집합은 CPU가 매우 구체적인 작업(예: _두 숫자를 비교하거나_ _특정 메모리 위치에 이 숫자를 넣기_)을 수행할 수 있는 명령(command)으로 해석됩니다. 그러나 CPU마다 명령어 집합이 다르기 때문에 특정 CPU 용으로 작성된 명령어는 동일한 명령어 집합을 공유하지 않는 다른 CPU에서는 사용할 수 없었습니다. 이는 프로그램을 다른 유형의 시스템으로 **이식**(대대적인 수정 없이 사용 가능)할 수 없다는 것을 의미하며, 그러기 위해선 처음부터 프로그램을 다시 만들어야 했습니다.

## 어셈블리어 (Assembly Language)

기계어는 사람이 읽고 이해하기 너무 어렵기 때문에 어셈블리어가 발명되었습니다. 기계어와 달리 어셈블리어에서는 각 명령어가 비트 세트가 아닌 짧은 약어로 식별되며, 이름과 여러 숫자를 사용할 수 있습니다.

다음은 위 명령어를 어셈블리어로 표현한 것입니다: `mov al, 061h`

덕분에 어셈블리는 기계어보다 훨씬 쉽게 읽고 쓸 수 있습니다. 그러나 CPU는 어셈블리어를 직접 이해할 수 없습니다. 따라서 어셈블리 프로그램을 컴퓨터에서 실행하기 전에 먼저 기계어로 번역해야 합니다. 이 작업은 **어셈블러**라는 프로그램을 통해 진행됩니다. 어셈블리어로 작성된 프로그램은 매우 빠른 경향이 있으며, 오늘날에도 속도가 중요한 분야에서는 여전히 어셈블리어가 사용되고 있습니다.

하지만 어셈블리에는 여전히 몇 가지 단점이 있습니다. 첫째, 어셈블리어는 간단한 작업이더라도 수많은 명령어를 필요로 합니다. 개별 명령어 하나하나는 사람이 어느 정도 읽을 수 있지만, 전체 프로그램이 무엇을 하는지 이해하는 것은 쉽지 않을 수 있습니다(문장을 글자 하나하나를 보고 이해하는 것과 비슷합니다). 둘째, 어셈블리어는 여전히 이식성이 떨어집니다. 한 CPU용으로 작성된 어셈블리 프로그램은 다른 명령어 집합을 사용하는 하드웨어에서 작동하지 않을 가능성이 높으며, 다른 환경에서 작동시키기 위해서는 처음부터 다시 작성하거나 광범위하게 수정해야 합니다.

## 고급 언어 (High-level Languages)

가독성과 이식성 문제를 해결하기 위해 C, C++, Pascal과 같은 새로운 프로그래밍 언어가 개발되었고, 이후에는 Java, Javascript, Perl과 같은 언어가 개발되었습니다. 이러한 언어들은 프로그래머가 프로그램이 어떤 종류의 컴퓨터에서 실행되는지에 대해 크게 신경 쓰지 않고 프로그램을 작성할 수 있도록 설계되었기 때문에 **고급 언어(High-level Languages)**라고 불립니다.

다음은 위 명령어를 C/C++에서 동일하게 표현한 것입니다: `a = 97;`

어셈블리 프로그램과 마찬가지로 고급 언어로 작성된 프로그램도 컴퓨터가 이해할 수 있는 형식으로 번역해야 실행할 수 있습니다. 이 번역 작업에는 크게 컴파일과 인터프리터라는 두 가지 방법이 있습니다.

**컴파일러**는 소스 코드를 판독하고, 실행 가능한(executable) 독립 실행형 프로그램을 생성하는 프로그램입니다. 한번 코드가 실행 파일로 만들어지면 더 이상 컴파일러 없이도 프로그램을 실행할 수 있게 됩니다. 초창기 컴파일러는 원시적이었고 느리고 최적화되지 않은 코드를 생성했습니다. 하지만 수년에 걸쳐 컴파일러는 빠르고 최적화된 코드를 생성하는 데 있어 매우 훌륭해졌으며, 경우에 따라서는 어셈블리어를 사용하는 사람보다도 더 나은 성능을 발휘하기도 합니다!

다음은 컴파일 프로세스를 단순화한 이미지입니다:

> <img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Compiling-min.png?ezimgfmt=rs:521x161/rscb2/ng:webp/ngcb2">
{: .prompt-img }

C++ 프로그램은 대부분 컴파일되는 경우가 많으므로 조만간 컴파일러에 대해 더 자세히 설명해드리도록 하겠습니다.

인터프리터는 소스 코드의 명령어를 실행 파일로 컴파일하지 않고 그대로 실행하는 프로그램입니다. 인터프리터는 컴파일러보다 더 유연한 편이지만, 프로그램을 실행할 때마다 인터프리팅 프로세스를 수행해야 하기 때문에 상대적으로 효율성이 떨어집니다. 다시 말해, 프로그램을 실행할 때마다 인터프리터가 필요하다는 뜻입니다.

다음은 인터프리터 프로세스를 간략하게 표현한 것입니다:

><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Interpreting-min.png?ezimgfmt=rs:537x45/rscb2/ng:webp/ngcb2">
{: .prompt-img }

> **참고 자료(선택 사항)**
> 
> 컴파일러와 인터프리터의 장단점에 대한 비교는 [여기](https://stackoverflow.com/questions/38491212/difference-between-compiled-and-interpreted-languages/38491646#38491646){:target="_blank"}에서 확인할 수 있습니다.
{: .prompt-general }

대부분의 언어는 컴파일 또는 인터프리트할 수 있습니다. 단, 전통적으로 C, C++, Pascal과 같은 언어는 컴파일하는 것이 일반적이며, Perl, Javascript와 같은 "스크립팅" 언어는 인터프리트하는 것이 일반적입니다. Java와 같은 몇몇 언어는 이 두 가지를 혼합하여 사용하기도 합니다.

고급 언어에는 여러 가지 유용한 속성이 있습니다.

첫째, 고급 언어는 명령어가 우리가 매일 사용하는 자연어에 가깝기 때문에 읽고 쓰기가 훨씬 쉽습니다. 둘째, 고급 언어는 저급 언어에 비해 동일한 작업을 수행하는 데 필요한 명령어의 수가 적어 프로그램이 더 간결하고 이해하기 편합니다. C++에서는 `a = b * 2 + 5;` 와 같은 작업을 단 한 줄로 수행할 수 있습니다. 반면 어셈블리어에서는 이 작업을 수행하려면 최소 5~6개의 명령어가 필요합니다.

셋째, 다양한 시스템에 적합하도록 프로그램을 컴파일(또는 인터프리트)할 수 있으며, 다양한 CPU에서 실행하기 위해 프로그램을 따로 변경할 필요가 없습니다(해당 CPU에 맞게 다시 컴파일하기만 하면 됩니다). 예를 들어:

><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Portability-min.png?ezimgfmt=rs:481x261/rscb2/ng:webp/ngcb2">
{: .prompt-img }

이식성에는 일반적으로 두 가지 예외가 있습니다.

첫 번째는 Microsoft Windows와 같은 많은 운영 체제에는 개발자가 코드에서 사용할 수 있도록 지원하는 플랫폼별 기능이 포함되어 있다는 점입니다. 이러한 기능을 사용하면 특정 운영 체제용 프로그램을 훨씬 쉽게 작성할 수 있지만 이식성이 저하될 수 있습니다. 따라서 이 튜토리얼에서는 플랫폼별 코드를 사용하지 않을 것입니다.

두 번째는 일부 컴파일러는 컴파일러별 확장자(extensions)도 지원하는데, 이러한 확장자를 사용하면 해당 확장자를 지원하지 않는 다른 컴파일러에서는 프로그램을 수정하지 않고는 컴파일할 수 없게 됩니다. 자세한 내용은 나중에 컴파일러를 설치한 후에 설명하겠습니다.

## 규칙, 모범 사례 및 경고

이 튜토리얼을 진행하는 동안 다음 세 가지 카테고리로 핵심 내용을 강조할 것입니다:

> 규칙
> 
> 규칙은 언어에 요구되는 _필수_ 지침입니다. 일반적으로 규칙을 준수하지 않으면 프로그램이 제대로 실행되지 않을 수 있습니다.
{: .prompt-tip }

> 모범 사례
>
> 모범 사례는 표준 또는 적극 권장되는 방식이기 때문에 _권장드리는_ 방식입니다. 즉, 이는 대부분의 사람들이 그렇게 하고 있거나(그렇지 않으면 사람들이 예상하지 못한 결과를 초래할 수 있으므로), 다른 대안들보다 우수한 방법입니다.
{: .prompt-tip }

> 경고
>
> 경고는 예상치 못한 결과를 초래할 수 있으므로 _절대 해서는_ 안 되는 행동입니다.
{: .prompt-danger }
